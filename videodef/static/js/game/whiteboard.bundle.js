/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./puzzle/index.js":
/*!*************************!*\
  !*** ./puzzle/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPuzzleOnBoard: () => (/* binding */ createPuzzleOnBoard),\n/* harmony export */   setupWhiteboardPuzzleSaveLoad: () => (/* binding */ setupWhiteboardPuzzleSaveLoad)\n/* harmony export */ });\n/* harmony import */ var _puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./puzzle-logic.js */ \"./puzzle/puzzle-logic.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\nwindow.createPuzzleSeparately = createPuzzleSeparately;\n\n/**\r\n * Конвертирует строку Data URL в объект Blob.\r\n * Необходимо для отправки пользовательских изображений на сервер через FormData.\r\n * @param {string} dataURL - Строка Data URL\r\n * @returns {Blob|null} - Объект Blob или null в случае ошибки.\r\n */\nfunction dataURLtoBlob(dataURL) {\n  try {\n    // Разделяем строку на метаданные (MIME-тип) и данные Base64\n    var parts = dataURL.split(';base64,');\n    var contentType = parts[0].split(':')[1];\n    // Декодируем Base64 строку в бинарную строку\n    var raw = window.atob(parts[1]);\n    var rawLength = raw.length;\n    // Создаем массив 8-битных беззнаковых целых чисел\n    var uInt8Array = new Uint8Array(rawLength);\n    for (var i = 0; i < rawLength; ++i) {\n      uInt8Array[i] = raw.charCodeAt(i);\n    }\n    // Создаем и возвращаем Blob с указанным MIME-типом\n    return new Blob([uInt8Array], {\n      type: contentType\n    });\n  } catch (error) {\n    console.error(\"Ошибка конвертации Data URL в Blob:\", error);\n    return null;\n  }\n}\n\n/**\r\n * Отображает список сохраненных пазлов в указанном контейнере.\r\n * @param {HTMLElement} container - DOM-элемент (например, div), куда будет добавлен список.\r\n * @param {Array<object>} puzzles - Массив объектов, каждый из которых представляет сохраненный пазл.\r\n */\nfunction displayPuzzleList(container, puzzles) {\n  if (puzzles.length === 0) {\n    container.innerHTML = '<p>У вас пока нет сохраненных пазлов.</p>';\n    return;\n  }\n  var ul = document.createElement('ul');\n  // Проходим по каждому объекту пазла в массиве\n  puzzles.forEach(function (puzzle) {\n    var li = document.createElement('li');\n    var imageInfo = puzzle.has_user_image ? \"(свое фото)\" : \"(пресет)\";\n    li.textContent = \"\".concat(puzzle.name, \" (\").concat(puzzle.grid_size, \"x\").concat(puzzle.grid_size, \") \").concat(imageInfo);\n    // Сохраняем полные данные пазла в data-атрибут 'puzzleData' в виде JSON строки.\n    li.dataset.puzzleData = JSON.stringify(puzzle);\n    li.dataset.id = puzzle.id;\n    ul.appendChild(li);\n  });\n  container.innerHTML = '';\n  container.appendChild(ul);\n}\n\n/**\r\n * Инициализирует общую логику сохранения и загрузки пазлов.\r\n * @param {function} getPuzzleState - Функция, возвращающая объект с текущим состоянием пазла для сохранения\r\n * @param {function} applyLoadedState - Функция, принимающая загруженные данные пазла и применяющая их к текущему экземпляру.\r\n * @param {object} controls - Объект с DOM-элементами управления { saveButton, loadButton, loadModal, loadListContainer, loadConfirmBtn, loadCancelBtn }\r\n */\nfunction initSaveLoadFeatures(getPuzzleState, applyLoadedState, controls) {\n  var saveButton = controls.saveButton,\n    loadButton = controls.loadButton,\n    loadModal = controls.loadModal,\n    loadListContainer = controls.loadListContainer,\n    loadConfirmBtn = controls.loadConfirmBtn,\n    loadCancelBtn = controls.loadCancelBtn;\n\n  // Проверка наличия всех необходимых элементов управления для сохранения и загрузки\n  if (!saveButton || !loadButton || !loadModal || !loadListContainer || !loadConfirmBtn || !loadCancelBtn) {\n    console.error(\"Ошибка сохранения/загрузки: отсутствует один или несколько элементов управления.\");\n    if (loadModal) {\n      console.error(\"Отсутствуют элементы:\", {\n        saveButton: saveButton,\n        loadButton: loadButton,\n        loadModal: loadModal,\n        loadListContainer: loadListContainer,\n        loadConfirmBtn: loadConfirmBtn,\n        loadCancelBtn: loadCancelBtn\n      });\n    } else {\n      console.warn(\"Модальное окно загрузки не найдено, загрузка может быть ограничена\");\n      if (!saveButton) {\n        console.error(\"Кнопка сохранения также отсутствует.\");\n        return;\n      }\n    }\n  }\n  var selectedPuzzleToLoad = null;\n\n  // --- Обработчик нажатия кнопки \"Сохранить\" ---\n  var saveHandler = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var currentState, name, gridSize, piecePositions, selectedImage, presetElements, customImageInputEl, formData, isPreset, imageBlob, filename, response, result;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            currentState = getPuzzleState();\n            if (currentState) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 3:\n            // Извлекаем необходимые данные из полученного состояния\n            name = currentState.name, gridSize = currentState.gridSize, piecePositions = currentState.piecePositions, selectedImage = currentState.selectedImage, presetElements = currentState.presetElements, customImageInputEl = currentState.customImageInputEl; // --- Валидация данных перед сохранением ---\n            if (name) {\n              _context.next = 7;\n              break;\n            }\n            alert(\"Пожалуйста, введите название для сохранения.\");\n            return _context.abrupt(\"return\");\n          case 7:\n            if (selectedImage) {\n              _context.next = 10;\n              break;\n            }\n            alert(\"Пожалуйста, выберите или загрузите изображение.\");\n            return _context.abrupt(\"return\");\n          case 10:\n            if (!(!piecePositions || piecePositions.length !== gridSize * gridSize)) {\n              _context.next = 14;\n              break;\n            }\n            alert(\"Ошибка: Некорректные данные о позициях элементов.\");\n            console.error(\"Недопустимые позиции элементов для сохранения\", piecePositions, \"Grid size:\", gridSize);\n            return _context.abrupt(\"return\");\n          case 14:\n            // --- Формирование данных для отправки на сервер с использованием FormData ---\n            formData = new FormData();\n            formData.append('name', name);\n            formData.append('gridSize', gridSize);\n            formData.append('piecePositions', JSON.stringify(piecePositions));\n\n            // Определяем, используется ли изображение-пресет или пользовательское изображение\n            isPreset = false;\n            if (presetElements && presetElements.length > 0) {\n              presetElements.forEach(function (preset) {\n                var presetSrc = preset.dataset.src || preset.src;\n                if (presetSrc === selectedImage) {\n                  isPreset = true;\n                  var presetPath = selectedImage.replace(window.location.origin, '');\n                  if (presetPath.startsWith('/static/')) {\n                    presetPath = presetPath.substring('/static/'.length);\n                  }\n                  formData.append('preset_image_path', presetPath);\n                }\n              });\n            }\n            if (!(!isPreset && selectedImage.startsWith('data:image'))) {\n              _context.next = 31;\n              break;\n            }\n            imageBlob = dataURLtoBlob(selectedImage);\n            if (!imageBlob) {\n              _context.next = 27;\n              break;\n            }\n            filename = customImageInputEl && customImageInputEl.files.length > 0 ? customImageInputEl.files[0].name : \"upload.\".concat(imageBlob.type.split('/')[1] || 'png');\n            formData.append('user_image_file', imageBlob, filename);\n            _context.next = 29;\n            break;\n          case 27:\n            alert(\"Ошибка конвертации пользовательского изображения для сохранения.\");\n            return _context.abrupt(\"return\");\n          case 29:\n            _context.next = 41;\n            break;\n          case 31:\n            if (isPreset) {\n              _context.next = 41;\n              break;\n            }\n            if (!(selectedImage && (selectedImage.includes('/media/puzzle_images/') || selectedImage.includes('/static/')))) {\n              _context.next = 38;\n              break;\n            }\n            alert(\"Невозможно сохранить: выбранное изображение было загружено ранее. Пожалуйста, выберите пресет или загрузите изображение заново, чтобы сохранить текущее состояние.\");\n            console.warn(\"Не удается сохранить существующее пользовательское изображение по URL-адресу:\", selectedImage);\n            return _context.abrupt(\"return\");\n          case 38:\n            alert(\"Не удалось определить источник изображения для сохранения.\");\n            console.warn(\"Невозможно сохранить источник изображения:\", selectedImage);\n            return _context.abrupt(\"return\");\n          case 41:\n            // --- Отправка запроса на сервер для сохранения пазла ---\n            saveButton.textContent = 'Сохранение...';\n            saveButton.disabled = true;\n            _context.prev = 43;\n            _context.next = 46;\n            return fetch(savePuzzleUrl, {\n              method: 'POST',\n              headers: {\n                'X-CSRFToken': csrfToken,\n                'Accept': 'application/json'\n              },\n              body: formData\n            });\n          case 46:\n            response = _context.sent;\n            _context.next = 49;\n            return response.json();\n          case 49:\n            result = _context.sent;\n            if (response.ok && result.status === 'success') {\n              alert(result.message || 'Пазл сохранен!');\n            } else {\n              alert(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u0435\\u043D\\u0438\\u044F: \".concat(result.message || response.statusText));\n            }\n            _context.next = 57;\n            break;\n          case 53:\n            _context.prev = 53;\n            _context.t0 = _context[\"catch\"](43);\n            alert(\"Сетевая ошибка при сохранении.\");\n            console.error(\"Ошибка сохранения:\", _context.t0);\n          case 57:\n            _context.prev = 57;\n            saveButton.textContent = saveButton.dataset.originalText || 'Сохранить';\n            saveButton.disabled = false;\n            return _context.finish(57);\n          case 61:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[43, 53, 57, 61]]);\n    }));\n    return function saveHandler() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  // --- Назначение обработчика на кнопку \"Сохранить\" ---\n  if (saveButton) {\n    saveButton.dataset.originalText = saveButton.textContent;\n    saveButton.removeEventListener('click', saveButton.clickHandler);\n    saveButton.addEventListener('click', saveHandler);\n    saveButton.clickHandler = saveHandler;\n  }\n\n  // --- Логика Загрузки ---\n  if (loadButton && loadModal && loadListContainer && loadConfirmBtn && loadCancelBtn) {\n    // --- Обработчик нажатия кнопки \"Загрузить\" ---\n    var loadHandler = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              loadListContainer.innerHTML = '<p>Загрузка...</p>';\n              loadConfirmBtn.disabled = true;\n              selectedPuzzleToLoad = null;\n              loadModal.style.display = 'flex';\n              _context2.prev = 4;\n              _context2.next = 7;\n              return fetch(loadPuzzlesUrl, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'application/json'\n                }\n              });\n            case 7:\n              response = _context2.sent;\n              _context2.next = 10;\n              return response.json();\n            case 10:\n              result = _context2.sent;\n              if (response.ok && result.status === 'success') {\n                displayPuzzleList(loadListContainer, result.puzzles);\n              } else {\n                loadListContainer.innerHTML = \"<p>\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \".concat(result.message || 'Не удалось загрузить.', \"</p>\");\n              }\n              _context2.next = 18;\n              break;\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](4);\n              loadListContainer.innerHTML = '<p>Сетевая ошибка при загрузке.</p>';\n              console.error(\"Ошибка в списке загрузки:\", _context2.t0);\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[4, 14]]);\n      }));\n      return function loadHandler() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    loadButton.removeEventListener('click', loadButton.clickHandler);\n    loadButton.addEventListener('click', loadHandler);\n    loadButton.clickHandler = loadHandler;\n\n    // --- Обработчики Модального окна ---\n    var cancelHandler = function cancelHandler() {\n      loadModal.style.display = 'none';\n    };\n    loadCancelBtn.removeEventListener('click', loadCancelBtn.clickHandler);\n    loadCancelBtn.addEventListener('click', cancelHandler);\n    loadCancelBtn.clickHandler = cancelHandler;\n    var listClickHandler = function listClickHandler(event) {\n      var target = event.target;\n      if (target.tagName === 'LI') {\n        loadListContainer.querySelectorAll('li').forEach(function (item) {\n          return item.classList.remove('selected');\n        });\n        target.classList.add('selected');\n        try {\n          selectedPuzzleToLoad = JSON.parse(target.dataset.puzzleData);\n          loadConfirmBtn.disabled = false;\n        } catch (e) {\n          console.error(\"Ошибка парсинга данных пазла:\", e);\n          selectedPuzzleToLoad = null;\n          loadConfirmBtn.disabled = true;\n        }\n      }\n    };\n    loadListContainer.removeEventListener('click', loadListContainer.clickHandler);\n    loadListContainer.addEventListener('click', listClickHandler);\n    loadListContainer.clickHandler = listClickHandler;\n    var confirmHandler = function confirmHandler() {\n      if (!selectedPuzzleToLoad) return;\n      applyLoadedState(selectedPuzzleToLoad);\n      loadModal.style.display = 'none';\n    };\n    loadConfirmBtn.removeEventListener('click', loadConfirmBtn.clickHandler);\n    loadConfirmBtn.addEventListener('click', confirmHandler);\n    loadConfirmBtn.clickHandler = confirmHandler;\n  } else if (loadButton) {\n    loadButton.disabled = true;\n    loadButton.title = \"Модальное окно для загрузки не найдено\";\n    console.warn(\"Кнопка загрузки найдена, но отсутствуют элементы модального окна.\");\n  }\n  console.log(\"Функции сохранения/загрузки инициализированны\");\n}\n\n/**\r\n * Назначает обработчики для пользовательского изображения, пресетов и сложности.\r\n * @param {object} options - Объект с параметрами настройки.\r\n * @param {HTMLInputElement} options.customInput - Поле для загрузки пользовательского фото.\r\n * @param {Array<HTMLElement>} options.presets - Массив HTML-элементов, представляющих пресеты изображений.\r\n * @param {HTMLSelectElement} options.difficultySelect - Выпадающий список для выбора сложности (размера сетки).\r\n * @param {HTMLButtonElement} [options.startBtn] - Кнопка \"Начать игру\"\r\n * @param {object} options.puzzleParams - Объект параметров текущего пазла\r\n * @param {HTMLElement} options.puzzleContainer - Контейнер для кусочков пазла\r\n * @param {HTMLElement} options.message - Элемент для сообщений\r\n * @param {boolean} [options.instantUpdate=false] - Обновлять ли пазл сразу\r\n * @param {function} [options.onStateChange] - Колбэк при изменении состояния\r\n */\nfunction setupPuzzleControls(_ref3) {\n  var customInput = _ref3.customInput,\n    presets = _ref3.presets,\n    difficultySelect = _ref3.difficultySelect,\n    startBtn = _ref3.startBtn,\n    puzzleParams = _ref3.puzzleParams,\n    puzzleContainer = _ref3.puzzleContainer,\n    message = _ref3.message,\n    _ref3$instantUpdate = _ref3.instantUpdate,\n    instantUpdate = _ref3$instantUpdate === void 0 ? false : _ref3$instantUpdate,\n    onStateChange = _ref3.onStateChange;\n  // Проверка наличия обязательных элементов и параметров\n  if (!customInput || !presets || !difficultySelect || !puzzleParams || !puzzleContainer || !message) {\n    console.error(\"настройка элементов управления пазлом: отсутствуют необходимые элементы или параметры.\");\n    return;\n  }\n\n  // Пользовательское изображение\n  var customImageHandler = function customImageHandler(e) {\n    var file = e.target.files[0];\n    if (file) {\n      var reader = new FileReader();\n      reader.onload = function () {\n        puzzleParams.selectedImage = reader.result;\n        puzzleParams.isPreset = false;\n        puzzleParams.imageFile = file;\n        presets.forEach(function (p) {\n          return p.classList.remove('selected');\n        });\n        var previewContainer = document.getElementById('image-preview-container');\n        var previewImg = document.getElementById('image-preview');\n        var previewText = document.getElementById('image-preview-text');\n        if (previewContainer && previewImg && previewText) {\n          previewImg.src = reader.result;\n          previewText.textContent = \"\\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F: \".concat(file.name);\n          previewContainer.style.display = 'block';\n        }\n        if (instantUpdate) {\n          (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n        }\n        if (onStateChange) onStateChange(puzzleParams);\n      };\n      reader.readAsDataURL(file);\n    } else {\n      if (puzzleParams.selectedImage && puzzleParams.selectedImage.startsWith('data:image')) {\n        puzzleParams.selectedImage = null;\n        puzzleParams.imageFile = null;\n        var previewContainer = document.getElementById('image-preview-container');\n        if (previewContainer) previewContainer.style.display = 'none';\n        if (instantUpdate) puzzleContainer.innerHTML = '<p>Выберите изображение</p>';\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    }\n  };\n  customInput.removeEventListener('change', customInput.changeHandler);\n  customInput.addEventListener('change', customImageHandler);\n  customInput.changeHandler = customImageHandler;\n\n  // Пресеты\n  presets.forEach(function (preset) {\n    var presetClickHandler = function presetClickHandler() {\n      presets.forEach(function (p) {\n        return p.classList.remove('selected');\n      });\n      preset.classList.add('selected');\n      puzzleParams.selectedImage = preset.dataset.src;\n      puzzleParams.isPreset = true;\n      puzzleParams.imageFile = null;\n      customInput.value = '';\n      var previewContainer = document.getElementById('image-preview-container');\n      if (previewContainer) previewContainer.style.display = 'none';\n      if (instantUpdate) {\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    };\n    preset.removeEventListener('click', preset.clickHandler);\n    preset.addEventListener('click', presetClickHandler);\n    preset.clickHandler = presetClickHandler;\n  });\n\n  // Сложность (размер сетки)\n  var difficultyHandler = function difficultyHandler(e) {\n    var newSize = parseInt(e.target.value, 10);\n    if (newSize !== puzzleParams.gridSize) {\n      puzzleParams.gridSize = newSize;\n      puzzleParams.piecePositions = [];\n      console.log(\"\\u0420\\u0430\\u0437\\u043C\\u0435\\u0440 \\u0441\\u0435\\u0442\\u043A\\u0438 \\u0438\\u0437\\u043C\\u0435\\u043D\\u0435\\u043D \\u043D\\u0430 \".concat(NewSize, \", \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u0438 \\u043E\\u0447\\u0438\\u0449\\u0435\\u043D\\u044B.\"));\n      if (instantUpdate) {\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    }\n  };\n  difficultySelect.removeEventListener('change', difficultySelect.changeHandler);\n  difficultySelect.addEventListener('change', difficultyHandler);\n  difficultySelect.changeHandler = difficultyHandler;\n\n  // Кнопка \"Начать игру\"\n  if (startBtn) {\n    var startHandler = function startHandler() {\n      if (!puzzleParams.selectedImage) {\n        alert(\"Пожалуйста, выберите или загрузите изображение.\");\n        return;\n      }\n      var useLoadedPositions = puzzleParams.piecePositions && puzzleParams.piecePositions.length === puzzleParams.gridSize * puzzleParams.gridSize;\n      (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, useLoadedPositions);\n    };\n    startBtn.removeEventListener('click', startBtn.clickHandler);\n    startBtn.addEventListener('click', startHandler);\n    startBtn.clickHandler = startHandler;\n  }\n  console.log(\"Настройка элементов управления пазлом завершена.\");\n}\n\n/**\r\n * Инициализирует интерфейс и логику для отдельной страницы пазла.\r\n * Эта функция находит все необходимые элементы управления на странице, настраивает их\r\n * с помощью `setupPuzzleControls` и инициализирует функции сохранения/загрузки\r\n * с помощью `initSaveLoadFeatures`. Пазл создается по нажатию кнопки \"Начать игру\".\r\n */\nfunction createPuzzleSeparately() {\n  var _getPuzzleParts = (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.getPuzzleParts)(),\n    _getPuzzleParts2 = _slicedToArray(_getPuzzleParts, 3),\n    localPuzzleParams = _getPuzzleParts2[0],\n    puzzleContainer = _getPuzzleParts2[1],\n    message = _getPuzzleParts2[2];\n  localPuzzleParams.onWhiteboard = false;\n  localPuzzleParams.name = \"\";\n  var wrapper = document.getElementById('puzzle-wrapper');\n  if (!wrapper) {\n    console.error(\"#puzzle-wrapper not found!\");\n    return;\n  }\n  wrapper.innerHTML = '';\n  wrapper.appendChild(puzzleContainer);\n  wrapper.appendChild(message);\n\n  // Находим контролы на странице игры\n  var customInput = document.getElementById('custom-image');\n  var difficultySelect = document.getElementById('difficulty');\n  var presetsNodeList = document.querySelectorAll('.preset');\n  var startBtn = document.getElementById('start-game');\n  var puzzleNameInput = document.getElementById('puzzle-name');\n  var saveButton = document.getElementById('save-puzzle-btn');\n  var loadButton = document.getElementById('load-puzzle-btn');\n  var loadModal = document.getElementById('load-puzzle-modal');\n  var loadListContainer = document.getElementById('load-list-container');\n  var loadConfirmBtn = document.getElementById('load-confirm-btn');\n  var loadCancelBtn = document.getElementById('load-cancel-btn');\n  if (!customInput || !difficultySelect || !(presetsNodeList !== null && presetsNodeList !== void 0 && presetsNodeList.length) || !startBtn || !puzzleNameInput || !saveButton || !loadButton || !loadModal) {\n    console.error(\"Элементы управления на странице пазлов не найдены!\");\n    return;\n  }\n  var presets = Array.from(presetsNodeList);\n\n  // Настройка обработчиков\n  setupPuzzleControls({\n    customInput: customInput,\n    presets: presets,\n    difficultySelect: difficultySelect,\n    startBtn: startBtn,\n    puzzleParams: localPuzzleParams,\n    puzzleContainer: puzzleContainer,\n    message: message,\n    instantUpdate: false,\n    onStateChange: function onStateChange(params) {\n      if (params && typeof params.name !== 'undefined') {\n        puzzleNameInput.value = params.name;\n      }\n    }\n  });\n\n  // Собираем текущее состояние пазла данной страницы для сохранения\n  var getPuzzleStateForSeparatePage = function getPuzzleStateForSeparatePage() {\n    localPuzzleParams.name = puzzleNameInput.value.trim();\n    return {\n      name: localPuzzleParams.name,\n      gridSize: localPuzzleParams.gridSize,\n      piecePositions: localPuzzleParams.piecePositions,\n      selectedImage: localPuzzleParams.selectedImage,\n      presetElements: presets,\n      customImageInputEl: customInput\n    };\n  };\n\n  // Применяем загруженное состояние пазла к странице\n  var applyLoadedStateForSeparatePage = function applyLoadedStateForSeparatePage(puzzleData) {\n    console.log(\"Применение загруженного состояния к отдельной странице:\", puzzleData);\n    localPuzzleParams.gridSize = puzzleData.grid_size;\n    localPuzzleParams.piecePositions = puzzleData.piece_positions || [];\n    localPuzzleParams.name = puzzleData.name;\n    localPuzzleParams.selectedImage = puzzleData.image_url;\n    localPuzzleParams.isPreset = !!puzzleData.preset_path;\n    localPuzzleParams.imageFile = null;\n    difficultySelect.value = puzzleData.grid_size;\n    puzzleNameInput.value = puzzleData.name;\n    customInput.value = '';\n    var previewContainer = document.getElementById('image-preview-container');\n    if (previewContainer) previewContainer.style.display = 'none';\n    presets.forEach(function (p) {\n      return p.classList.remove('selected');\n    });\n    if (localPuzzleParams.isPreset) {\n      var found = false;\n      presets.forEach(function (preset) {\n        var presetSrcRelative = (preset.dataset.src || preset.src).replace(window.location.origin, '');\n        var loadedUrlRelative = puzzleData.image_url.replace(window.location.origin, '');\n        if (presetSrcRelative === loadedUrlRelative) {\n          preset.classList.add('selected');\n          found = true;\n        }\n      });\n      if (!found) console.warn(\"Загруженное предустановленное изображение не найдено:\", puzzleData.image_url);\n    } else {\n      // Показываем превью для загруженного пользовательского фото\n      var previewImg = document.getElementById('image-preview');\n      var previewText = document.getElementById('image-preview-text');\n      if (previewContainer && previewImg && previewText && puzzleData.image_url) {\n        previewImg.src = puzzleData.image_url;\n        previewText.textContent = \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E: \".concat(puzzleData.name);\n        previewContainer.style.display = 'block';\n      } else {\n        console.log(\"Загруженное пользовательское изображение:\", puzzleData.image_url);\n      }\n    }\n    alert(\"\\u041F\\u0430\\u0437\\u043B \\\"\".concat(puzzleData.name, \"\\\" (\").concat(puzzleData.grid_size, \"x\").concat(puzzleData.grid_size, \") \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D. \\u041D\\u0430\\u0436\\u043C\\u0438\\u0442\\u0435 \\\"\\u041D\\u0430\\u0447\\u0430\\u0442\\u044C \\u0438\\u0433\\u0440\\u0443\\\", \\u0447\\u0442\\u043E\\u0431\\u044B \\u0441\\u043E\\u0431\\u0440\\u0430\\u0442\\u044C \\u0435\\u0433\\u043E.\"));\n    puzzleContainer.innerHTML = '<p>Пазл загружен. Нажмите \"Начать игру\".</p>';\n    message.style.display = 'none';\n  };\n\n  // Инициализируем Save/Load\n  initSaveLoadFeatures(getPuzzleStateForSeparatePage, applyLoadedStateForSeparatePage, {\n    saveButton: saveButton,\n    loadButton: loadButton,\n    loadModal: loadModal,\n    loadListContainer: loadListContainer,\n    loadConfirmBtn: loadConfirmBtn,\n    loadCancelBtn: loadCancelBtn\n  });\n  if (presets.length > 0 && !localPuzzleParams.selectedImage) {\n    presets[0].click();\n  }\n  puzzleContainer.innerHTML = '<p>Выберите настройки и нажмите \"Начать игру\"</p>';\n  message.style.display = 'none';\n  console.log(\"Страница пазла инициализирована\");\n}\n\n/**\r\n * Создает интерактивный пазл внутри игрового контейнера на доске.\r\n * @param {HTMLElement} gameWrapper - Родительский контейнер для пазла\r\n */\nfunction createPuzzleOnBoard(gameWrapper) {\n  var _getPuzzleParts3 = (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.getPuzzleParts)(),\n    _getPuzzleParts4 = _slicedToArray(_getPuzzleParts3, 3),\n    localPuzzleParams = _getPuzzleParts4[0],\n    puzzleContainer = _getPuzzleParts4[1],\n    message = _getPuzzleParts4[2];\n\n  // Устанавливаем параметры по умолчанию для нового пазла на доске\n  localPuzzleParams.onWhiteboard = true;\n  localPuzzleParams.name = \"Новый пазл\";\n  localPuzzleParams.gridSize = 2;\n  localPuzzleParams.selectedImage = null;\n  localPuzzleParams.isPreset = false;\n  localPuzzleParams.imageFile = null;\n  localPuzzleParams.piecePositions = [];\n  gameWrapper.puzzleParams = localPuzzleParams;\n  gameWrapper.puzzleContainer = puzzleContainer;\n  gameWrapper.puzzleMessage = message;\n  var closeButton = gameWrapper.querySelector('.paste-game-close');\n  var resizeHandle = gameWrapper.querySelector('.resize-handle');\n  gameWrapper.innerHTML = '';\n  if (closeButton) gameWrapper.appendChild(closeButton);\n  if (resizeHandle) gameWrapper.appendChild(resizeHandle);\n  gameWrapper.appendChild(puzzleContainer);\n  gameWrapper.appendChild(message);\n  puzzleContainer.innerHTML = '<p style=\"text-align: center; padding: 20px;\">Активируйте пазл и выберите настройки в панели справа.</p>';\n  message.style.display = 'none';\n  console.log(\"Экземпляр пазла создан на доске и ожидает активации\");\n}\n\n/**\r\n * Настраивает контролы и Save/Load для активного пазла на доске.\r\n */\nfunction setupWhiteboardPuzzleSaveLoad() {\n  console.log(\"Пытаюсь настроить сохранение/загрузку для активного пазла на доске...\");\n\n  // Проверяем, найден ли активный пазл и содержит ли он необходимые данные\n  var activeGameWrapper = document.querySelector('.paste-game-wrapper.active-game');\n  if (!activeGameWrapper || !activeGameWrapper.puzzleParams || !activeGameWrapper.puzzleContainer || !activeGameWrapper.puzzleMessage) {\n    console.warn(\"На доске не найден активный пазл или в нём отсутствуют необходимые данные. Настройка пропущена.\");\n    return;\n  }\n  var activePuzzleParams = activeGameWrapper.puzzleParams;\n  var activePuzzleContainer = activeGameWrapper.puzzleContainer;\n  var activePuzzleMessage = activeGameWrapper.puzzleMessage;\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) {\n    console.error(\"Панель настроек не найдена. Не удается настроить элементы управления пазлом на доске\");\n    return;\n  }\n  var puzzleNameInput = settingsPanel.querySelector('#puzzle-name');\n  var customInput = settingsPanel.querySelector('#custom-image');\n  var difficultySelect = settingsPanel.querySelector('#difficulty');\n  var presetsNodeList = settingsPanel.querySelectorAll('.preset');\n  var saveButton = settingsPanel.querySelector('#save-puzzle-btn');\n  var loadButton = settingsPanel.querySelector('#load-puzzle-btn');\n  var startBtn = settingsPanel.querySelector('#start-game');\n  var loadModal = document.getElementById('load-puzzle-modal');\n  var loadListContainer = document.getElementById('load-list-container');\n  var loadConfirmBtn = document.getElementById('load-confirm-btn');\n  var loadCancelBtn = document.getElementById('load-cancel-btn');\n  if (!puzzleNameInput || !customInput || !difficultySelect || !(presetsNodeList !== null && presetsNodeList !== void 0 && presetsNodeList.length) || !saveButton || !loadButton) {\n    console.error(\"Основные элементы управления пазлом  (#puzzle-name, #custom-image, #difficulty, .preset, #save-puzzle-btn, #load-puzzle-btn) отсутствуют на панели настроек доски!\");\n    return;\n  }\n  var presets = Array.from(presetsNodeList);\n  if (startBtn) {\n    startBtn.style.display = 'none';\n  }\n\n  // Настраиваем обработчика\n  setupPuzzleControls({\n    customInput: customInput,\n    presets: presets,\n    difficultySelect: difficultySelect,\n    startBtn: null,\n    puzzleParams: activePuzzleParams,\n    puzzleContainer: activePuzzleContainer,\n    message: activePuzzleMessage,\n    instantUpdate: true,\n    onStateChange: function onStateChange(params) {\n      if (params && typeof params.name !== 'undefined') {\n        puzzleNameInput.value = params.name;\n      }\n      console.log(\"Изменено состояние активного пазла на доске:\", params);\n    }\n  });\n  puzzleNameInput.value = activePuzzleParams.name || '';\n  difficultySelect.value = activePuzzleParams.gridSize;\n\n  // Сбрасываем выделение пресетов и состояние превью в панели настроек\n  presets.forEach(function (p) {\n    return p.classList.remove('selected');\n  });\n  var previewContainer = settingsPanel.querySelector('#image-preview-container');\n  var previewImg = settingsPanel.querySelector('#image-preview');\n  var previewText = settingsPanel.querySelector('#image-preview-text');\n  if (previewContainer) previewContainer.style.display = 'none';\n\n  // Устанавливаем правильный пресет или показываем превью пользовательского фото в панели настроек\n  if (activePuzzleParams.isPreset && activePuzzleParams.selectedImage) {\n    var found = false;\n    presets.forEach(function (preset) {\n      if ((preset.dataset.src || preset.src) === activePuzzleParams.selectedImage) {\n        preset.classList.add('selected');\n        found = true;\n      }\n    });\n    if (!found) console.warn(\"Предустановленное изображение активного пазла не найдено в панели настроек\", activePuzzleParams.selectedImage);\n  } else if (!activePuzzleParams.isPreset && activePuzzleParams.selectedImage) {\n    if (previewContainer && previewImg && previewText) {\n      previewImg.src = activePuzzleParams.selectedImage;\n      previewText.textContent = activePuzzleParams.imageFile ? \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E: \".concat(activePuzzleParams.imageFile.name) : 'Загруженное изображение';\n      previewContainer.style.display = 'block';\n    }\n  }\n  customInput.value = '';\n\n  // Получаем состояние активного пазла для сохранения\n  var getPuzzleStateForWhiteboard = function getPuzzleStateForWhiteboard() {\n    var currentActiveWrapper = document.querySelector('.paste-game-wrapper.active-game');\n    if (!currentActiveWrapper || currentActiveWrapper !== activeGameWrapper || !currentActiveWrapper.puzzleParams) {\n      alert(\"Активный пазл изменился или не найден. Сохранение отменено.\");\n      return null;\n    }\n    var params = currentActiveWrapper.puzzleParams;\n    params.name = puzzleNameInput.value.trim();\n    if (!params.name) {\n      alert(\"Введите название для сохранения.\");\n      puzzleNameInput.focus();\n      return null;\n    }\n    if (!params.piecePositions || params.piecePositions.length !== params.gridSize * params.gridSize) {\n      alert(\"Ошибка: Пазл не инициализирован или данные о позициях некорректны. Перемешайте элементы или измените настройки перед сохранением.\");\n      console.error(\"Невозможно сохранить: недопустимые позиции элементов\", params.piecePositions, \"for grid size\", params.gridSize);\n      return null;\n    }\n    return {\n      name: params.name,\n      gridSize: params.gridSize,\n      piecePositions: params.piecePositions,\n      selectedImage: params.selectedImage,\n      presetElements: presets,\n      customImageInputEl: customInput\n    };\n  };\n\n  // Применяем загруженное состояние к активному пазлу\n  var applyLoadedStateForWhiteboard = function applyLoadedStateForWhiteboard(puzzleData) {\n    var currentActiveWrapper = document.querySelector('.paste-game-wrapper.active-game');\n    if (!currentActiveWrapper || currentActiveWrapper !== activeGameWrapper || !currentActiveWrapper.puzzleParams) {\n      alert(\"Активный пазл изменился или не найден. Загрузка отменена.\");\n      return;\n    }\n    var targetParams = currentActiveWrapper.puzzleParams;\n    var targetContainer = currentActiveWrapper.puzzleContainer;\n    var targetMessage = currentActiveWrapper.puzzleMessage;\n    console.log(\"Применение загруженного состояния к пазлу на доске:\", puzzleData);\n    targetParams.gridSize = puzzleData.grid_size;\n    targetParams.piecePositions = puzzleData.piece_positions || [];\n    targetParams.name = puzzleData.name;\n    targetParams.selectedImage = puzzleData.image_url;\n    targetParams.isPreset = !!puzzleData.preset_path;\n    targetParams.imageFile = null;\n    puzzleNameInput.value = targetParams.name;\n    difficultySelect.value = targetParams.gridSize;\n    customInput.value = '';\n    if (previewContainer) previewContainer.style.display = 'none';\n    presets.forEach(function (p) {\n      return p.classList.remove('selected');\n    });\n    if (targetParams.isPreset) {\n      var _found = false;\n      presets.forEach(function (preset) {\n        var presetSrcRelative = (preset.dataset.src || preset.src).replace(window.location.origin, '');\n        var loadedUrlRelative = puzzleData.image_url.replace(window.location.origin, '');\n        if (presetSrcRelative === loadedUrlRelative) {\n          preset.classList.add('selected');\n          _found = true;\n        }\n      });\n      if (!_found) console.warn(\"Загруженное предустановленное изображение не найдено:\", puzzleData.image_url);\n    } else {\n      // Показываем превью для загруженного пользовательского фото\n      if (previewContainer && previewImg && previewText && puzzleData.image_url) {\n        previewImg.src = puzzleData.image_url;\n        previewText.textContent = \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E: \".concat(puzzleData.name);\n        previewContainer.style.display = 'block';\n      } else {\n        console.log(\"Загруженное изображение пользователя:\", puzzleData.image_url);\n      }\n    }\n    (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(targetContainer, targetParams, targetMessage, true);\n    alert(\"\\u041F\\u0430\\u0437\\u043B \\\"\".concat(puzzleData.name, \"\\\" \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D \\u0432 \\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043D\\u0442\\u0435\\u0439\\u043D\\u0435\\u0440.\"));\n  };\n\n  // Инициализируем функции Сохранения и Загрузки\n  initSaveLoadFeatures(getPuzzleStateForWhiteboard, applyLoadedStateForWhiteboard, {\n    saveButton: saveButton,\n    loadButton: loadButton,\n    loadModal: loadModal,\n    loadListContainer: loadListContainer,\n    loadConfirmBtn: loadConfirmBtn,\n    loadCancelBtn: loadCancelBtn\n  });\n  console.log(\"Настройка сохранения / загрузки завершена для активного пазла на доске.\");\n}\n\n//# sourceURL=webpack://frontend/./puzzle/index.js?");

/***/ }),

/***/ "./puzzle/puzzle-logic.js":
/*!********************************!*\
  !*** ./puzzle/puzzle-logic.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPuzzle: () => (/* binding */ createPuzzle),\n/* harmony export */   getPuzzleParts: () => (/* binding */ getPuzzleParts),\n/* harmony export */   placePieces: () => (/* binding */ placePieces),\n/* harmony export */   updatePuzzleImage: () => (/* binding */ updatePuzzleImage)\n/* harmony export */ });\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\r\n * Генерирует базовые компоненты для пазла\r\n * @returns {Array} [params, container, message] - Параметры, контейнер и сообщение\r\n */\nfunction getPuzzleParts() {\n  // Параметры пазла по умолчанию\n  var puzzleParams = {\n    gridSize: 2,\n    // Размер сетки (2x2)\n    piecePositions: [],\n    // Позиции элементов\n    selectedImage: images + '/british-cat.jpg',\n    // Изображение по умолчанию\n    selectedPiece: null // Выбранный элемент\n  };\n  var puzzleContainer = createPuzzleContainer();\n  var message = createGameMessage();\n  return [puzzleParams, puzzleContainer, message];\n}\n\n/**\r\n * Создает пазл в указанном контейнере\r\n * @param {HTMLElement} puzzleContainer - Контейнер для элементов\r\n * @param {Object} puzzleParams - Параметры пазла\r\n * @param {HTMLElement} message - Элемент для отображения сообщений\r\n * @param {boolean} useExistingPositions - Если true, использует puzzleParams.piecePositions, иначе генерирует новые\r\n */\nfunction createPuzzle(puzzleContainer, puzzleParams, message) {\n  var useExistingPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  puzzleContainer.innerHTML = '';\n  message.style.display = 'none';\n\n  // Генерируем новые позиции только если не используем существующие\n  if (!useExistingPositions || !puzzleParams.piecePositions || puzzleParams.piecePositions.length !== puzzleParams.gridSize * puzzleParams.gridSize) {\n    console.log(\"Generating new shuffled positions...\");\n    puzzleParams.piecePositions = shuffle(_toConsumableArray(Array(puzzleParams.gridSize * puzzleParams.gridSize).keys()));\n  } else {\n    console.log(\"Using existing positions:\", puzzleParams.piecePositions);\n  }\n\n  // Создание элементов пазла\n  var _loop = function _loop() {\n    var piece = document.createElement('div');\n    piece.classList.add('puzzle-piece');\n    piece.id = \"piece-\".concat(i + 1);\n    // data-index всегда соответствует оригинальному индексу куска (0..N-1)\n    piece.setAttribute('data-index', i);\n\n    // Расчет размеров элемента\n    var percent = 100 / puzzleParams.gridSize;\n    piece.style.width = \"\".concat(percent, \"%\");\n    piece.style.height = \"\".concat(percent, \"%\");\n    piece.style.backgroundSize = \"\".concat(puzzleParams.gridSize * 100, \"% \").concat(puzzleParams.gridSize * 100, \"%\");\n\n    // Обработчик клика на элемент\n    piece.addEventListener('click', function () {\n      return handlePieceClick(puzzleContainer, puzzleParams, piece, message);\n    });\n    puzzleContainer.appendChild(piece);\n  };\n  for (var i = 0; i < puzzleParams.gridSize * puzzleParams.gridSize; i++) {\n    _loop();\n  }\n\n  // Установка фона и расстановка по местам\n  updatePuzzleImage(puzzleContainer, puzzleParams);\n}\n\n/**\r\n * Обновляет фоновое изображение и расставляет элементы пазла\r\n * @param {HTMLElement} puzzleContainer - Контейнер с элементами пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n */\nfunction updatePuzzleImage(puzzleContainer, puzzleParams) {\n  var pieces = puzzleContainer.querySelectorAll('.puzzle-piece');\n  pieces.forEach(function (piece, idx) {\n    piece.style.backgroundImage = \"url(\\\"\".concat(puzzleParams.selectedImage, \"\\\")\");\n    // Расчет фоновой позиции для текущего куска (индекс idx)\n    var row = Math.floor(idx / puzzleParams.gridSize);\n    var col = idx % puzzleParams.gridSize;\n    piece.style.backgroundPosition = \"\".concat(col * -100, \"% \").concat(row * -100, \"%\");\n  });\n  placePieces(puzzleContainer, puzzleParams);\n}\n\n// Создание контейнера для пазлов\nfunction createPuzzleContainer() {\n  var container = document.createElement('div');\n  container.classList.add('puzzle-container');\n  var ids = '123456789'.split('');\n  ids.forEach(function (id, index) {\n    var piece = document.createElement('div');\n    piece.classList.add('puzzle-piece');\n    piece.id = \"piece-\".concat(id);\n    piece.setAttribute('draggable', 'true');\n    piece.setAttribute('data-index', id);\n    container.appendChild(piece);\n  });\n  return container;\n}\n\n/**\r\n * Располагает элементы пазла в соответствии с текущими позициями\r\n * @param {HTMLElement} puzzleContainer - Контейнер пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n */\nfunction placePieces(puzzleContainer, puzzleParams) {\n  var pieces = puzzleContainer.querySelectorAll('.puzzle-piece');\n  var gridPositions = [];\n  var percent = 100 / puzzleParams.gridSize;\n\n  // Генерация сетки\n  for (var row = 0; row < puzzleParams.gridSize; row++) {\n    for (var col = 0; col < puzzleParams.gridSize; col++) {\n      gridPositions.push([col * percent, row * percent]);\n    }\n  }\n\n  // Распределение элементов по позициям\n  pieces.forEach(function (piece, idx) {\n    var _gridPositions$puzzle = _slicedToArray(gridPositions[puzzleParams.piecePositions[idx]], 2),\n      x = _gridPositions$puzzle[0],\n      y = _gridPositions$puzzle[1];\n    piece.style.left = \"\".concat(x, \"%\");\n    piece.style.top = \"\".concat(y, \"%\");\n\n    // Расчет позиции фона\n    var row = Math.floor(idx / puzzleParams.gridSize);\n    var col = idx % puzzleParams.gridSize;\n    piece.style.backgroundPosition = \"\".concat(col * -100, \"% \").concat(row * -100, \"%\");\n  });\n}\n\n/**\r\n * Алгоритм Фишера-Йетса для перемешивания массива\r\n * @param {Array} array - Исходный массив\r\n * @returns {Array} Перемешанный массив\r\n */\nfunction shuffle(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var _ref = [array[j], array[i]];\n    array[i] = _ref[0];\n    array[j] = _ref[1];\n  }\n  return array;\n}\n\n/**\r\n * Обрабатывает клик на элементе пазла\r\n * @param {HTMLElement} puzzleContainer - Контейнер пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n * @param {HTMLElement} piece - Выбранный элемент\r\n * @param {HTMLElement} message - Элемент сообщения\r\n */\nfunction handlePieceClick(puzzleContainer, puzzleParams, piece, message) {\n  if (!puzzleParams.selectedPiece) {\n    puzzleParams.selectedPiece = piece;\n    piece.style.outline = '2px solid red';\n  } else if (puzzleParams.selectedPiece === piece) {\n    piece.style.outline = '';\n    puzzleParams.selectedPiece = null;\n  } else {\n    swapPieces(puzzleContainer, puzzleParams, puzzleParams.selectedPiece, piece);\n    puzzleParams.selectedPiece.style.outline = '';\n    puzzleParams.selectedPiece = null;\n    checkVictory(puzzleParams, message);\n  }\n}\n\n// Перемещение элементов пазла\nfunction swapPieces(puzzleContainer, puzzleParams, p1, p2) {\n  var i1 = Array.from(puzzleContainer.querySelectorAll('.puzzle-piece')).indexOf(p1);\n  var i2 = Array.from(puzzleContainer.querySelectorAll('.puzzle-piece')).indexOf(p2);\n  var _ref2 = [puzzleParams.piecePositions[i2], puzzleParams.piecePositions[i1]];\n  puzzleParams.piecePositions[i1] = _ref2[0];\n  puzzleParams.piecePositions[i2] = _ref2[1];\n  placePieces(puzzleContainer, puzzleParams);\n}\n\n// Проверка условий победы\nfunction checkVictory(puzzleParams, message) {\n  var isVictory = puzzleParams.piecePositions.every(function (val, idx) {\n    return val === idx;\n  });\n  if (isVictory) {\n    message.style.display = 'block';\n  }\n}\n\n// Создание сообщение о победе\nfunction createGameMessage() {\n  var message = document.createElement('div');\n  message.id = 'game-message';\n  message.style.display = 'none';\n  message.textContent = 'Поздравляем! Вы собрали пазл!';\n  return message;\n}\n\n//# sourceURL=webpack://frontend/./puzzle/puzzle-logic.js?");

/***/ }),

/***/ "./whiteboard.js":
/*!***********************!*\
  !*** ./whiteboard.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./puzzle/index.js */ \"./puzzle/index.js\");\n\n\n// Получение ссылок на элементы canvas\nvar imageCanvas = document.getElementById('image-layer');\nvar drawCanvas = document.getElementById('draw-layer');\n\n// Контексты рисования\nvar imageCtx = imageCanvas.getContext('2d');\nvar drawCtx = drawCanvas.getContext('2d');\n\n// Состояние приложения\nvar drawing = false; // Флаг процесса рисования\nvar prev = {}; // Предыдущие координаты курсора\nvar imagesList = []; // Список загруженных изображений\nvar activeImage = null; // Активное изображение для перемещения\nvar dragOffset = {\n  x: 0,\n  y: 0\n}; // Смещение при перетаскивании\nvar isResizing = false; // Флаг изменения размера\nvar isDragging = false; // Флаг перетаскивания\nvar currentTool = 'pen'; // Текущий инструмент\nvar currentLineWidth = 2; // Толщина линии\nvar currentColor = '#000000'; // Цвет по умолчанию\n\n// Инициализация WebSocket соединения\nvar ws = new WebSocket(\"ws://\".concat(window.location.host, \"/ws/whiteboard/\"));\n\n// Обработчик входящих сообщений\nws.onmessage = function (e) {\n  var data = JSON.parse(e.data);\n\n  // Обработка рисования\n  if (data.type === \"draw\") {\n    var x0 = data.x0,\n      y0 = data.y0,\n      x1 = data.x1,\n      y1 = data.y1,\n      color = data.color,\n      lineWidth = data.lineWidth;\n    drawLine(drawCtx, x0, y0, x1, y1, color, lineWidth);\n  }\n\n  // Обработка загрузки изображений\n  if (data.type === 'image') {\n    var img = new Image();\n    img.onload = function () {\n      var imageObj = {\n        img: img,\n        x: 50,\n        y: 50,\n        width: 200,\n        height: 200\n      };\n      imagesList.push(imageObj);\n      redrawImages();\n    };\n    img.src = data.dataURL;\n  }\n\n  // Обработка очистки доски\n  if (data.type === 'clear') {\n    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);\n    imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n    imagesList = [];\n  }\n};\n\n// Инициализация инструментов\ndocument.getElementById('pen_btn').addEventListener('click', function () {\n  currentTool = 'pen';\n  toggleToolButtons('pen_btn');\n});\ndocument.getElementById('eraser_btn').addEventListener('click', function () {\n  currentTool = 'eraser';\n  toggleToolButtons('eraser_btn');\n});\n\n// Обработчики параметров рисования\ndocument.getElementById('colorPicker').addEventListener('input', function (e) {\n  currentColor = e.target.value;\n});\ndocument.getElementById('thickness').addEventListener('input', function (e) {\n  currentLineWidth = parseInt(e.target.value);\n});\n\n/**\r\n * Управляет визуальной активностью кнопок инструментов.\r\n * Убирает класс 'active' со всех кнопок и добавляет его выбранной кнопке.\r\n * @param {string} activeId - ID активной кнопки инструмента\r\n */\nfunction toggleToolButtons(activeId) {\n  document.querySelectorAll('.tool').forEach(function (btn) {\n    return btn.classList.remove('active');\n  });\n  document.getElementById(activeId).classList.add('active');\n}\n\n// Обработчики событий мыши\ndrawCanvas.addEventListener('mousedown', function (e) {\n  var x = e.offsetX,\n    y = e.offsetY;\n  activeImage = getImageAt(x, y);\n  if (activeImage) {\n    if (overResizeHandle(x, y, activeImage)) {\n      isResizing = true;\n    } else {\n      isDragging = true;\n      dragOffset.x = x - activeImage.x;\n      dragOffset.y = y - activeImage.y;\n    }\n  } else {\n    drawing = true;\n    prev = {\n      x: x,\n      y: y\n    };\n  }\n});\ndrawCanvas.addEventListener('mouseup', function () {\n  drawing = false;\n  isDragging = false;\n  isResizing = false;\n  activeImage = null;\n});\ndrawCanvas.addEventListener('mousemove', function (e) {\n  var x = e.offsetX,\n    y = e.offsetY;\n  if (drawing && !someonesDragging) {\n    var current = {\n      x: x,\n      y: y\n    };\n    var color = currentTool === 'pen' ? currentColor : '#ffffff';\n    var message = {\n      type: 'draw',\n      x0: prev.x,\n      y0: prev.y,\n      x1: current.x,\n      y1: current.y,\n      color: color,\n      lineWidth: currentLineWidth\n    };\n    ws.send(JSON.stringify(message));\n    drawLine(drawCtx, prev.x, prev.y, current.x, current.y, color, currentLineWidth);\n    prev = current;\n  } else if (isDragging && activeImage) {\n    activeImage.x = x - dragOffset.x;\n    activeImage.y = y - dragOffset.y;\n    redrawImages();\n  } else if (isResizing && activeImage) {\n    activeImage.width = x - activeImage.x;\n    activeImage.height = y - activeImage.y;\n    redrawImages();\n  }\n});\n\n/**\r\n * Рисует линию на заданном контексте.\r\n * @param {CanvasRenderingContext2D} ctx - Контекст рисования\r\n * @param {number} x0 - Начальная координата X\r\n * @param {number} y0 - Начальная координата Y\r\n * @param {number} x1 - Конечная координата X\r\n * @param {number} y1 - Конечная координата Y\r\n * @param {string} color - Цвет линии\r\n * @param {number} lineWidth - Толщина линии\r\n */\nfunction drawLine(ctx, x0, y0, x1, y1, color, lineWidth) {\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  ctx.beginPath();\n  ctx.moveTo(x0, y0);\n  ctx.lineTo(x1, y1);\n  ctx.stroke();\n}\n\n// Загрузка пользовательских изображений\ndocument.getElementById('img-upload').addEventListener('change', function () {\n  var file = this.files[0];\n  if (!file) return;\n  var reader = new FileReader();\n  reader.onload = function () {\n    var dataURL = reader.result;\n    ws.send(JSON.stringify({\n      type: 'image',\n      dataURL: dataURL\n    }));\n  };\n  reader.readAsDataURL(file);\n});\n\n/**\r\n * Очищает доску и сбрасывает загруженные изображения.\r\n */\nfunction clearBoard() {\n  ws.send(JSON.stringify({\n    type: 'clear'\n  }));\n  document.getElementById('img-upload').value = '';\n}\ndocument.querySelector(\"#clear_btn\").addEventListener(\"click\", function () {\n  clearBoard();\n});\n\n/**\r\n * Перерисовывает все изображения на слое изображений и отображает маркеры изменения размера.\r\n */\nfunction redrawImages() {\n  imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n  imagesList.forEach(function (imgObj) {\n    imageCtx.drawImage(imgObj.img, imgObj.x, imgObj.y, imgObj.width, imgObj.height);\n    drawResizeHandle(imageCtx, imgObj);\n  });\n}\n\n// Вспомогательные функции\nfunction getImageAt(x, y) {\n  for (var i = imagesList.length - 1; i >= 0; i--) {\n    var img = imagesList[i];\n    if (x >= img.x && x <= img.x + img.width && y >= img.y && y <= img.y + img.height) {\n      return img;\n    }\n  }\n  return null;\n}\nfunction drawResizeHandle(ctx, imgObj) {\n  var size = 10;\n  ctx.fillStyle = '#00f';\n  ctx.fillRect(imgObj.x + imgObj.width - size, imgObj.y + imgObj.height - size, size, size);\n}\nfunction overResizeHandle(x, y, imgObj) {\n  var size = 10;\n  return x >= imgObj.x + imgObj.width - size && x <= imgObj.x + imgObj.width && y >= imgObj.y + imgObj.height - size && y <= imgObj.y + imgObj.height;\n}\n\n/**\r\n * Адаптирует размер холста (canvas) под размеры родительского контейнера.\r\n */\nfunction resizeCanvasToDisplaySize() {\n  var wrapper = imageCanvas.parentElement;\n  var width = wrapper.clientWidth;\n  var height = wrapper.clientHeight;\n  imageCanvas.width = width;\n  imageCanvas.height = height;\n  drawCanvas.width = width;\n  drawCanvas.height = height;\n  redrawImages();\n}\nwindow.addEventListener('load', resizeCanvasToDisplaySize);\nwindow.addEventListener('resize', resizeCanvasToDisplaySize);\n\n// Инициализация меню игр\nvar dropdown = document.getElementById(\"game-menu\");\nvar gamesBtn = document.getElementById(\"games_btn\");\nvar gameMenu = document.getElementById(\"game-menu\");\ngamesBtn.addEventListener(\"click\", function () {\n  updategameMenuPos();\n  dropdown.classList.toggle(\"show\");\n});\nwindow.addEventListener(\"resize\", function () {\n  updategameMenuPos();\n});\n\n/**\r\n * Обновляет позицию выпадающего меню игр относительно кнопки.\r\n */\nfunction updategameMenuPos() {\n  var rect = gamesBtn.getBoundingClientRect();\n  gameMenu.style.top = \"\".concat(rect.bottom + window.scrollY, \"px\");\n  gameMenu.style.left = \"\".concat(rect.left + window.scrollX, \"px\");\n}\nwindow.addEventListener(\"click\", function (e) {\n  if (!gamesBtn.contains(e.target) && !dropdown.contains(e.target)) {\n    dropdown.classList.remove(\"show\");\n  }\n});\n\n// Обработка добавления игры на доску\ndocument.querySelectorAll(\".game-option\").forEach(function (option) {\n  if (option.dataset.listenerAttached === 'true') {\n    return;\n  }\n  option.addEventListener(\"click\", function () {\n    var gameName = option.dataset.name;\n    var gameWrapper = addGamePasteGame();\n    gameWrapper.dataset.gameName = gameName;\n    updateGameSettings(gameName);\n    if (gameName === \"puzzles\") {\n      (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzleOnBoard)(gameWrapper);\n    }\n    dropdown.classList.remove(\"show\");\n    setTimeout(function () {\n      if (document.body.contains(gameWrapper)) {\n        gameWrapper.dispatchEvent(new MouseEvent('mousedown', {\n          bubbles: true\n        }));\n      }\n    }, 0);\n  });\n  option.dataset.listenerAttached = 'true';\n});\n\n/**\r\n * Создает и добавляет контейнер для вставляемой игры на доску.\r\n * @returns {HTMLDivElement} gameWrapper - созданный контейнер игры\r\n */\nfunction addGamePasteGame() {\n  var gameWrapper = document.createElement('div');\n  gameWrapper.className = 'paste-game-wrapper';\n  gameWrapper.style.left = '100px';\n  gameWrapper.style.top = '100px';\n  gameWrapper.style.width = '400px';\n  gameWrapper.style.height = '300px';\n  gameWrapper.style.aspectRatio = '4 / 3';\n  var closeBtn = document.createElement('button');\n  closeBtn.className = 'paste-game-close';\n  closeBtn.textContent = '×';\n  closeBtn.onclick = function () {\n    // Если удаляем активный элемент, очищаем настройки\n    if (gameWrapper.classList.contains('active-game')) {\n      clearDynamicSettings();\n    }\n    gameWrapper.remove();\n  };\n  gameWrapper.appendChild(closeBtn);\n  document.querySelector('.canvas-wrapper').appendChild(gameWrapper);\n  makeDraggable(gameWrapper);\n  makeResizable(gameWrapper);\n  gameWrapper.addEventListener('mousedown', function (e) {\n    // Игнорируем клики на кнопку закрытия и кружок изменения размера\n    if (e.target.closest('.paste-game-close') || e.target.classList.contains('resize-handle')) {\n      return;\n    }\n\n    // Проверяем, стал ли wrapper активным\n    if (!gameWrapper.classList.contains('active-game')) {\n      var gameName = gameWrapper.dataset.gameName;\n\n      // Снимаем активность и флаг 'settingsUpdated' со всех остальных\n      document.querySelectorAll('.paste-game-wrapper.active-game').forEach(function (activeWrapper) {\n        activeWrapper.classList.remove('active-game');\n        activeWrapper.dataset.settingsUpdated = 'false';\n        activeWrapper.style.borderColor = '';\n        activeWrapper.style.zIndex = '';\n      });\n\n      // Делаем текущий активным\n      gameWrapper.classList.add('active-game');\n      gameWrapper.style.borderColor = 'blue';\n      gameWrapper.style.zIndex = '100';\n\n      // Обновляем панель настроек, если нужно\n      if (gameName && gameWrapper.dataset.settingsUpdated !== 'true') {\n        updateGameSettings(gameName);\n        gameWrapper.dataset.settingsUpdated = 'true';\n\n        // Вызываем настройку обработчиков\n        if (gameName === \"puzzles\") {\n          (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.setupWhiteboardPuzzleSaveLoad)();\n        }\n      } else if (!gameName) {\n        clearDynamicSettings();\n      }\n    } else {\n      gameWrapper.style.zIndex = '100';\n    }\n  });\n  return gameWrapper;\n}\nvar someonesDragging = false;\n\n/**\r\n * Делает контейнер игры перетаскиваемым.\r\n * @param {HTMLDivElement} gameWrapper - Контейнер игры\r\n */\nfunction makeDraggable(gameWrapper) {\n  gameWrapper.isDragging = false;\n  gameWrapper.offsetX = 0;\n  gameWrapper.offsetY = 0;\n  gameWrapper.addEventListener('mousedown', function (e) {\n    if (e.target.closest('.paste-game-close')) return;\n    gameWrapper.isDragging = true;\n    someonesDragging = true;\n    var rect = gameWrapper.getBoundingClientRect();\n    var x = e.x,\n      y = e.y;\n    console.log(rect.left, rect.top);\n    gameWrapper.offsetX = x - rect.left;\n    gameWrapper.offsetY = y - rect.top;\n    gameWrapper.style.zIndex = 999;\n    document.body.style.userSelect = 'none';\n  });\n  document.addEventListener('mousemove', function (e) {\n    if (!gameWrapper.isDragging) return;\n    gameWrapper.style.left = \"\".concat(e.clientX - gameWrapper.offsetX - 100, \"px\");\n    gameWrapper.style.top = \"\".concat(e.clientY - gameWrapper.offsetY - 180, \"px\");\n  });\n  document.addEventListener('mouseup', function () {\n    if (gameWrapper.isDragging) {\n      gameWrapper.isDragging = false;\n      someonesDragging = false;\n      document.body.style.userSelect = '';\n    }\n  });\n}\n\n/**\r\n * Делает контейнер игры изменяемым по размеру.\r\n * @param {HTMLDivElement} gameWrapper - Контейнер игры\r\n */\nfunction makeResizable(gameWrapper) {\n  var resizeHandle = document.createElement('div');\n  resizeHandle.className = 'resize-handle';\n  gameWrapper.appendChild(resizeHandle);\n  gameWrapper.isResizing = false;\n  var startX, startY, startWidth, startHeight;\n  resizeHandle.addEventListener('mousedown', function (e) {\n    e.stopPropagation(); // чтобы drag и resize не конфликтовали\n    gameWrapper.isResizing = true;\n    someonesDragging = true;\n    var rect = gameWrapper.getBoundingClientRect();\n    startX = e.clientX;\n    startY = e.clientY;\n    startWidth = rect.width;\n    startHeight = rect.height;\n    document.body.style.userSelect = 'none';\n  });\n  document.addEventListener('mousemove', function (e) {\n    if (!gameWrapper.isResizing) return;\n    var dx = e.clientX - startX;\n    var dy = e.clientY - startY;\n    var newWidth = Math.max(200, startWidth + dx);\n    var newHeight = Math.max(150, startHeight + dy);\n    gameWrapper.style.width = \"\".concat(newWidth, \"px\");\n    gameWrapper.style.height = \"\".concat(newHeight, \"px\");\n  });\n  document.addEventListener('mouseup', function () {\n    if (gameWrapper.isResizing) {\n      gameWrapper.isResizing = false;\n      someonesDragging = false;\n      document.body.style.userSelect = '';\n    }\n  });\n}\n\n// Панель настроек\nvar toggleButton = document.getElementById('toggle-settings-btn');\nvar settingsPanel = document.querySelector('.settings-panel');\n\n// Открытие/Скрытие настроек\ntoggleButton.addEventListener('click', function () {\n  settingsPanel.classList.toggle('hidden');\n  if (settingsPanel.classList.contains('hidden')) {\n    toggleButton.textContent = 'Открыть настройки';\n  } else {\n    toggleButton.textContent = 'Закрыть настройки';\n  }\n});\n\n/**\r\n * Удаляет все динамически созданные элементы настроек игр.\r\n */\nfunction clearDynamicSettings() {\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) return;\n  var dynamicElements = settingsPanel.querySelectorAll('.dynamic-setting');\n  dynamicElements.forEach(function (el) {\n    return el.remove();\n  });\n  var puzzleSettingsContainer = settingsPanel.querySelector('.puzzle-settings-container');\n  if (puzzleSettingsContainer) {\n    puzzleSettingsContainer.remove();\n  }\n}\n\n/**\r\n * Обновляет панель настроек в зависимости от выбранной игры.\r\n * @param {string} gameName - Название выбранной игры\r\n */\nfunction updateGameSettings(gameName) {\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) {\n    console.error(\"Не найдена панель настроек для обновления настроек игры\");\n    return;\n  }\n  if (typeof images === 'undefined') {\n    console.error(\"'переменная images (путь к статическим изображениям) не определена.\");\n    return;\n  }\n  clearDynamicSettings();\n  if (gameName === \"puzzles\") {\n    // Очищаем существующие настройки для пазлов, если они были добавлены ранее\n    var existingSettings = document.querySelector('.puzzle-settings-container');\n    if (existingSettings) {\n      existingSettings.remove();\n    }\n    var settingsContainer = document.createElement('div');\n    settingsContainer.className = \"dynamic-setting puzzle-settings-container\"; // Контейнер для настроек пазлов\n\n    // Содержимое настроек\n    var content = \"\\n            <div class=\\\"modal-content\\\">\\n                <h2>\\u041D\\u0430\\u0441\\u0442\\u0440\\u043E\\u0439\\u043A\\u0438 \\u043F\\u0430\\u0437\\u043B\\u0430</h2>\\n                <label for=\\\"puzzle-name\\\">\\u041D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u043B\\u044F \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u0435\\u043D\\u0438\\u044F:</label>\\n                <input type=\\\"text\\\" id=\\\"puzzle-name\\\" placeholder=\\\"\\u041D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0430\\u0437\\u043B\\u0430\\\" style=\\\"width: 80%; padding: 8px; margin-bottom: 15px;\\\">\\n\\n                <h2>\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430</h2>\\n\\n                <div class=\\\"preset-images\\\">\\n                    <img src=\\\"\".concat(images, \"/british-cat.jpg\\\" class=\\\"preset\\\" data-src=\\\"\").concat(images, \"/british-cat.jpg\\\">\\n                    <img src=\\\"\").concat(images, \"/tree.png\\\" class=\\\"preset\\\" data-src=\\\"\").concat(images, \"/tree.png\\\">\\n                </div>\\n\\n                <label class=\\\"upload-label\\\">\\n                    \\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u044C \\u0441\\u0432\\u043E\\u0451:\\n                    <input type=\\\"file\\\" id=\\\"custom-image\\\" accept=\\\"image/*\\\">\\n                </label>\\n\\n                <div id=\\\"image-preview-container\\\" class=\\\"image-preview-container\\\" style=\\\"display: none; margin-top: 10px; text-align: center;\\\">\\n                    <img id=\\\"image-preview\\\" src=\\\"#\\\" alt=\\\"\\u041F\\u0440\\u0435\\u0434\\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\\" style=\\\"max-width: 100px; max-height: 100px; border: 1px solid #ccc; margin-bottom: 5px;\\\">\\n                    <p id=\\\"image-preview-text\\\" style=\\\"font-size: 0.9em; color: #555;\\\">\\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043D\\u043E\\u0435 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435.</p>\\n                </div>\\n\\n                <label for=\\\"difficulty\\\">\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u0441\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C:</label>\\n                <select id=\\\"difficulty\\\">\\n                    <option value=\\\"2\\\" selected>2x2</option>\\n                    <option value=\\\"3\\\">3x3</option>\\n                    <option value=\\\"4\\\">4x4</option>\\n                </select>\\n\\n                <div class=\\\"settings-buttons\\\">\\n                    <button id=\\\"start-game\\\">\\u041D\\u0430\\u0447\\u0430\\u0442\\u044C \\u0438\\u0433\\u0440\\u0443</button> <!-- \\u042D\\u0442\\u0430 \\u043A\\u043D\\u043E\\u043F\\u043A\\u0430 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0441\\u043A\\u0440\\u044B\\u0442\\u0430 JS -->\\n                    <button id=\\\"save-puzzle-btn\\\">\\u0421\\u043E\\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C</button>\\n                    <button id=\\\"load-puzzle-btn\\\">\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u044C</button>\\n                </div>\\n            </div>\\n        \");\n\n    // Вставляем содержимое в контейнер\n    settingsContainer.innerHTML = content;\n\n    // Добавляем в панель настроек\n    settingsPanel.appendChild(settingsContainer);\n  } else if (gameName === \"another-game\") {}\n}\n\n//# sourceURL=webpack://frontend/./whiteboard.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./whiteboard.js");
/******/ 	
/******/ })()
;