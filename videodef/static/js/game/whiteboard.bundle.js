/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./puzzle/index.js":
/*!*************************!*\
  !*** ./puzzle/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPuzzleOnBoard: () => (/* binding */ createPuzzleOnBoard),\n/* harmony export */   setupWhiteboardPuzzleSaveLoad: () => (/* binding */ setupWhiteboardPuzzleSaveLoad)\n/* harmony export */ });\n/* harmony import */ var _puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./puzzle-logic.js */ \"./puzzle/puzzle-logic.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\nwindow.createPuzzleSeparately = createPuzzleSeparately;\n\n/**\r\n * Конвертирует строку Data URL в объект Blob.\r\n * Необходимо для отправки пользовательских изображений на сервер через FormData.\r\n * @param {string} dataURL - Строка Data URL\r\n * @returns {Blob|null} - Объект Blob или null в случае ошибки.\r\n */\nfunction dataURLtoBlob(dataURL) {\n  try {\n    // Разделяем строку на метаданные (MIME-тип) и данные Base64\n    var parts = dataURL.split(';base64,');\n    var contentType = parts[0].split(':')[1];\n    // Декодируем Base64 строку в бинарную строку\n    var raw = window.atob(parts[1]);\n    var rawLength = raw.length;\n    // Создаем массив 8-битных беззнаковых целых чисел\n    var uInt8Array = new Uint8Array(rawLength);\n    for (var i = 0; i < rawLength; ++i) {\n      uInt8Array[i] = raw.charCodeAt(i);\n    }\n    // Создаем и возвращаем Blob с указанным MIME-типом\n    return new Blob([uInt8Array], {\n      type: contentType\n    });\n  } catch (error) {\n    console.error(\"Ошибка конвертации Data URL в Blob:\", error);\n    return null;\n  }\n}\n\n/**\r\n * Отображает список сохраненных пазлов в указанном контейнере.\r\n * @param {HTMLElement} container - DOM-элемент (например, div), куда будет добавлен список.\r\n * @param {Array<object>} puzzles - Массив объектов, каждый из которых представляет сохраненный пазл.\r\n */\nfunction displayPuzzleList(container, puzzles) {\n  if (puzzles.length === 0) {\n    container.innerHTML = '<p>У вас пока нет сохраненных пазлов.</p>';\n    return;\n  }\n  var ul = document.createElement('ul');\n  // Проходим по каждому объекту пазла в массиве\n  puzzles.forEach(function (puzzle) {\n    var li = document.createElement('li');\n    var imageInfo = puzzle.has_user_image ? \"(свое фото)\" : \"(пресет)\";\n    li.textContent = \"\".concat(puzzle.name, \" (\").concat(puzzle.grid_size, \"x\").concat(puzzle.grid_size, \") \").concat(imageInfo);\n    // Сохраняем полные данные пазла в data-атрибут 'puzzleData' в виде JSON строки.\n    li.dataset.puzzleData = JSON.stringify(puzzle);\n    li.dataset.id = puzzle.id;\n    ul.appendChild(li);\n  });\n  container.innerHTML = '';\n  container.appendChild(ul);\n}\n\n/**\r\n * Инициализирует общую логику сохранения и загрузки пазлов.\r\n * @param {function} getPuzzleState - Функция, возвращающая объект с текущим состоянием пазла для сохранения\r\n * @param {function} applyLoadedState - Функция, принимающая загруженные данные пазла и применяющая их к текущему экземпляру.\r\n * @param {object} controls - Объект с DOM-элементами управления { saveButton, loadButton, loadModal, loadListContainer, loadConfirmBtn, loadCancelBtn }\r\n */\nfunction initSaveLoadFeatures(getPuzzleState, applyLoadedState, controls) {\n  var saveButton = controls.saveButton,\n    loadButton = controls.loadButton,\n    loadModal = controls.loadModal,\n    loadListContainer = controls.loadListContainer,\n    loadConfirmBtn = controls.loadConfirmBtn,\n    loadCancelBtn = controls.loadCancelBtn;\n\n  // Проверка наличия всех необходимых элементов управления для сохранения и загрузки\n  if (!saveButton || !loadButton || !loadModal || !loadListContainer || !loadConfirmBtn || !loadCancelBtn) {\n    console.error(\"Ошибка сохранения/загрузки: отсутствует один или несколько элементов управления.\");\n    if (loadModal) {\n      console.error(\"Отсутствуют элементы:\", {\n        saveButton: saveButton,\n        loadButton: loadButton,\n        loadModal: loadModal,\n        loadListContainer: loadListContainer,\n        loadConfirmBtn: loadConfirmBtn,\n        loadCancelBtn: loadCancelBtn\n      });\n    } else {\n      console.warn(\"Модальное окно загрузки не найдено, загрузка может быть ограничена\");\n      if (!saveButton) {\n        console.error(\"Кнопка сохранения также отсутствует.\");\n        return;\n      }\n    }\n  }\n  var selectedPuzzleToLoad = null;\n\n  // --- Обработчик нажатия кнопки \"Сохранить\" ---\n  var saveHandler = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var currentState, name, gridSize, piecePositions, selectedImage, presetElements, customImageInputEl, puzzleId, action, formData, isPreset, imageBlob, filename, url, method, response, result, finalPuzzleId;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof isAuthenticated === 'undefined' || typeof loginUrl === 'undefined')) {\n              _context.next = 4;\n              break;\n            }\n            console.error(\"Ошибка: Переменные isAuthenticated или loginUrl не определены. Проверьте HTML-шаблон.\");\n            alert(\"Произошла ошибка конфигурации. Невозможно проверить статус пользователя.\");\n            return _context.abrupt(\"return\");\n          case 4:\n            if (isAuthenticated) {\n              _context.next = 8;\n              break;\n            }\n            alert(\"Чтобы сохранить игру, пожалуйста, войдите в свой аккаунт.\");\n            window.location.href = loginUrl; // Перенаправляем на страницу входа\n            return _context.abrupt(\"return\");\n          case 8:\n            currentState = getPuzzleState();\n            if (currentState) {\n              _context.next = 11;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 11:\n            // Извлекаем необходимые данные из полученного состояния\n            name = currentState.name, gridSize = currentState.gridSize, piecePositions = currentState.piecePositions, selectedImage = currentState.selectedImage, presetElements = currentState.presetElements, customImageInputEl = currentState.customImageInputEl; // Получаем puzzleId из dataset кнопки. Если его нет, это создание новой игры.\n            puzzleId = saveButton.dataset.puzzleId;\n            action = puzzleId ? 'update' : 'create'; // --- Валидация данных перед сохранением ---\n            if (name) {\n              _context.next = 17;\n              break;\n            }\n            alert(\"Пожалуйста, введите название для сохранения.\");\n            return _context.abrupt(\"return\");\n          case 17:\n            if (selectedImage) {\n              _context.next = 20;\n              break;\n            }\n            alert(\"Пожалуйста, выберите или загрузите изображение.\");\n            return _context.abrupt(\"return\");\n          case 20:\n            if (!(!piecePositions || piecePositions.length !== gridSize * gridSize)) {\n              _context.next = 24;\n              break;\n            }\n            alert(\"Ошибка: Некорректные данные о позициях элементов.\");\n            console.error(\"Недопустимые позиции элементов для сохранения\", piecePositions, \"Grid size:\", gridSize);\n            return _context.abrupt(\"return\");\n          case 24:\n            // --- Формирование данных для отправки на сервер с использованием FormData ---\n            formData = new FormData();\n            formData.append('name', name);\n            formData.append('gridSize', gridSize);\n            formData.append('piecePositions', JSON.stringify(piecePositions));\n\n            // Определяем, используется ли изображение-пресет или пользовательское изображение\n            isPreset = false;\n            if (presetElements && presetElements.length > 0) {\n              presetElements.forEach(function (preset) {\n                var presetSrc = preset.dataset.src || preset.src;\n                if (presetSrc === selectedImage) {\n                  isPreset = true;\n                  var presetPath = selectedImage.replace(window.location.origin, '');\n                  if (presetPath.startsWith('/static/')) {\n                    presetPath = presetPath.substring('/static/'.length);\n                  }\n                  formData.append('preset_image_path', presetPath);\n                }\n              });\n            }\n            if (!(!isPreset && selectedImage.startsWith('data:image'))) {\n              _context.next = 41;\n              break;\n            }\n            // Пользователь загрузил новый файл (или пере-загрузил тот же, но он теперь data:URL)\n            imageBlob = dataURLtoBlob(selectedImage);\n            if (!imageBlob) {\n              _context.next = 37;\n              break;\n            }\n            filename = customImageInputEl && customImageInputEl.files.length > 0 ? customImageInputEl.files[0].name : \"upload.\".concat(imageBlob.type.split('/')[1] || 'png');\n            formData.append('user_image_file', imageBlob, filename);\n            _context.next = 39;\n            break;\n          case 37:\n            alert(\"Ошибка конвертации пользовательского изображения для сохранения/обновления.\");\n            return _context.abrupt(\"return\");\n          case 39:\n            _context.next = 56;\n            break;\n          case 41:\n            if (!(!isPreset && action === 'create')) {\n              _context.next = 56;\n              break;\n            }\n            if (!(selectedImage && (selectedImage.includes('/media/puzzle_images/') || selectedImage.includes('/static/')))) {\n              _context.next = 48;\n              break;\n            }\n            alert(\"Для создания нового пазла: выбранное изображение было загружено ранее. Пожалуйста, выберите пресет или загрузите изображение заново.\");\n            console.warn(\"Попытка создать пазл с существующим URL пользовательского изображения:\", selectedImage);\n            return _context.abrupt(\"return\");\n          case 48:\n            if (!selectedImage) {\n              _context.next = 54;\n              break;\n            }\n            alert(\"Не удалось определить источник изображения для создания пазла. Выберите пресет или загрузите свое изображение.\");\n            console.warn(\"Невозможно создать пазл с источником изображения:\", selectedImage);\n            return _context.abrupt(\"return\");\n          case 54:\n            alert(\"Изображение не выбрано для создания пазла.\");\n            return _context.abrupt(\"return\");\n          case 56:\n            // --- Отправка запроса на сервер для сохранения/обновления пазла ---\n            url = action === 'update' && puzzleId ? updatePuzzleBaseUrl + puzzleId + '/' : savePuzzleUrl;\n            method = action === 'update' && puzzleId ? 'PUT' : 'POST';\n            saveButton.textContent = action === 'update' ? 'Обновление...' : 'Сохранение...';\n            saveButton.disabled = true;\n            _context.prev = 60;\n            _context.next = 63;\n            return fetch(url, {\n              method: method,\n              headers: {\n                'X-CSRFToken': csrfToken,\n                'Accept': 'application/json'\n              },\n              body: formData\n            });\n          case 63:\n            response = _context.sent;\n            _context.next = 66;\n            return response.json();\n          case 66:\n            result = _context.sent;\n            if (response.ok && result.status === 'success') {\n              alert(result.message || (action === 'update' ? 'Пазл обновлен!' : 'Пазл сохранен!'));\n            } else {\n              alert(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \".concat(action === 'update' ? 'обновления' : 'сохранения', \": \").concat(result.message || response.statusText));\n            }\n            _context.next = 74;\n            break;\n          case 70:\n            _context.prev = 70;\n            _context.t0 = _context[\"catch\"](60);\n            alert(\"\\u0421\\u0435\\u0442\\u0435\\u0432\\u0430\\u044F \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u043F\\u0440\\u0438 \".concat(action === 'update' ? 'обновлении' : 'сохранении', \".\"));\n            console.error(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \".concat(action === 'update' ? 'обновления' : 'сохранения', \":\"), _context.t0);\n          case 74:\n            _context.prev = 74;\n            finalPuzzleId = saveButton.dataset.puzzleId;\n            if (finalPuzzleId) {\n              // Если puzzleId все еще есть, значит, мы в режиме обновления\n              saveButton.textContent = saveButton.dataset.originalTextUpdate || 'Обновить пазл';\n            } else {\n              // Иначе - в режиме создания\n              saveButton.textContent = saveButton.dataset.originalTextCreate || 'Сохранить';\n            }\n            saveButton.disabled = false;\n            return _context.finish(74);\n          case 79:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[60, 70, 74, 79]]);\n    }));\n    return function saveHandler() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  // --- Назначение обработчика на кнопку \"Сохранить\" ---\n  if (saveButton) {\n    if (!saveButton.dataset.originalTextCreate) {\n      saveButton.dataset.originalTextCreate = saveButton.textContent;\n    }\n    saveButton.dataset.action = 'create';\n    saveButton.removeEventListener('click', saveButton.clickHandler);\n    saveButton.addEventListener('click', saveHandler);\n    saveButton.clickHandler = saveHandler;\n  }\n\n  // --- Логика Загрузки ---\n  if (loadButton && loadModal && loadListContainer && loadConfirmBtn && loadCancelBtn) {\n    // --- Обработчик нажатия кнопки \"Загрузить\" ---\n    var loadHandler = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(typeof isAuthenticated === 'undefined' || typeof loginUrl === 'undefined')) {\n                _context2.next = 4;\n                break;\n              }\n              console.error(\"Ошибка: Переменные isAuthenticated или loginUrl не определены. Проверьте HTML-шаблон.\");\n              alert(\"Произошла ошибка конфигурации. Невозможно проверить статус пользователя.\");\n              return _context2.abrupt(\"return\");\n            case 4:\n              if (isAuthenticated) {\n                _context2.next = 8;\n                break;\n              }\n              alert(\"Чтобы загрузить сохраненные игры, пожалуйста, войдите в свой аккаунт.\");\n              window.location.href = loginUrl; // Перенаправляем на страницу входа\n              return _context2.abrupt(\"return\");\n            case 8:\n              loadListContainer.innerHTML = '<p>Загрузка...</p>';\n              loadConfirmBtn.disabled = true;\n              selectedPuzzleToLoad = null;\n              loadModal.style.display = 'flex';\n              _context2.prev = 12;\n              _context2.next = 15;\n              return fetch(loadPuzzlesUrl, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'application/json'\n                }\n              });\n            case 15:\n              response = _context2.sent;\n              _context2.next = 18;\n              return response.json();\n            case 18:\n              result = _context2.sent;\n              if (response.ok && result.status === 'success') {\n                displayPuzzleList(loadListContainer, result.puzzles);\n              } else {\n                loadListContainer.innerHTML = \"<p>\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \".concat(result.message || 'Не удалось загрузить.', \"</p>\");\n              }\n              _context2.next = 26;\n              break;\n            case 22:\n              _context2.prev = 22;\n              _context2.t0 = _context2[\"catch\"](12);\n              loadListContainer.innerHTML = '<p>Сетевая ошибка при загрузке.</p>';\n              console.error(\"Ошибка в списке загрузки:\", _context2.t0);\n            case 26:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[12, 22]]);\n      }));\n      return function loadHandler() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    loadButton.removeEventListener('click', loadButton.clickHandler);\n    loadButton.addEventListener('click', loadHandler);\n    loadButton.clickHandler = loadHandler;\n\n    // --- Обработчики Модального окна ---\n    var cancelHandler = function cancelHandler() {\n      loadModal.style.display = 'none';\n    };\n    loadCancelBtn.removeEventListener('click', loadCancelBtn.clickHandler);\n    loadCancelBtn.addEventListener('click', cancelHandler);\n    loadCancelBtn.clickHandler = cancelHandler;\n    var listClickHandler = function listClickHandler(event) {\n      var target = event.target;\n      if (target.tagName === 'LI') {\n        loadListContainer.querySelectorAll('li').forEach(function (item) {\n          return item.classList.remove('selected');\n        });\n        target.classList.add('selected');\n        try {\n          selectedPuzzleToLoad = JSON.parse(target.dataset.puzzleData);\n          loadConfirmBtn.disabled = false;\n        } catch (e) {\n          console.error(\"Ошибка парсинга данных пазла:\", e);\n          selectedPuzzleToLoad = null;\n          loadConfirmBtn.disabled = true;\n        }\n      }\n    };\n    loadListContainer.removeEventListener('click', loadListContainer.clickHandler);\n    loadListContainer.addEventListener('click', listClickHandler);\n    loadListContainer.clickHandler = listClickHandler;\n    var confirmHandler = function confirmHandler() {\n      if (!selectedPuzzleToLoad) return;\n      applyLoadedState(selectedPuzzleToLoad);\n      loadModal.style.display = 'none';\n    };\n    loadConfirmBtn.removeEventListener('click', loadConfirmBtn.clickHandler);\n    loadConfirmBtn.addEventListener('click', confirmHandler);\n    loadConfirmBtn.clickHandler = confirmHandler;\n  } else if (loadButton) {\n    loadButton.disabled = true;\n    loadButton.title = \"Модальное окно для загрузки не найдено\";\n    console.warn(\"Кнопка загрузки найдена, но отсутствуют элементы модального окна.\");\n  }\n  console.log(\"Функции сохранения/загрузки инициализированны\");\n}\n\n/**\r\n * Назначает обработчики для пользовательского изображения, пресетов и сложности.\r\n * @param {object} options - Объект с параметрами настройки.\r\n * @param {HTMLInputElement} options.customInput - Поле для загрузки пользовательского фото.\r\n * @param {Array<HTMLElement>} options.presets - Массив HTML-элементов, представляющих пресеты изображений.\r\n * @param {HTMLSelectElement} options.difficultySelect - Выпадающий список для выбора сложности (размера сетки).\r\n * @param {HTMLButtonElement} [options.startBtn] - Кнопка \"Начать игру\"\r\n * @param {object} options.puzzleParams - Объект параметров текущего пазла\r\n * @param {HTMLElement} options.puzzleContainer - Контейнер для кусочков пазла\r\n * @param {HTMLElement} options.message - Элемент для сообщений\r\n * @param {boolean} [options.instantUpdate=false] - Обновлять ли пазл сразу\r\n * @param {function} [options.onStateChange] - Колбэк при изменении состояния (для отправки по WS или обновления UI)\r\n * @param {HTMLButtonElement} [options.saveBtnRef] - Ссылка на кнопку сохранения (для обновления ее текста/data-атрибутов)\r\n */\nfunction setupPuzzleControls(_ref3) {\n  var customInput = _ref3.customInput,\n    presets = _ref3.presets,\n    difficultySelect = _ref3.difficultySelect,\n    startBtn = _ref3.startBtn,\n    puzzleParams = _ref3.puzzleParams,\n    puzzleContainer = _ref3.puzzleContainer,\n    message = _ref3.message,\n    _ref3$instantUpdate = _ref3.instantUpdate,\n    instantUpdate = _ref3$instantUpdate === void 0 ? false : _ref3$instantUpdate,\n    onStateChange = _ref3.onStateChange,\n    saveBtnRef = _ref3.saveBtnRef;\n  // Проверка наличия обязательных элементов и параметров\n  if (!customInput || !presets || !difficultySelect || !puzzleParams || !puzzleContainer || !message) {\n    console.error(\"настройка элементов управления пазлом: отсутствуют необходимые элементы или параметры.\");\n    return;\n  }\n  var resetToCreateModeIfNeeded = function resetToCreateModeIfNeeded() {\n    if (puzzleParams.id && saveBtnRef) {\n      console.log(\"Ключевые настройки изменены после загрузки. Переход в режим создания нового пазла.\");\n      puzzleParams.id = null;\n      delete saveBtnRef.dataset.puzzleId;\n      saveBtnRef.dataset.action = 'create';\n      saveBtnRef.textContent = saveBtnRef.dataset.originalTextCreate || 'Сохранить';\n    }\n  };\n\n  // Пользовательское изображение\n  var customImageHandler = function customImageHandler(e) {\n    var file = e.target.files[0];\n    if (file) {\n      var reader = new FileReader();\n      reader.onload = function () {\n        if (puzzleParams.selectedImage !== reader.result) {\n          resetToCreateModeIfNeeded();\n        }\n        puzzleParams.selectedImage = reader.result;\n        puzzleParams.isPreset = false;\n        puzzleParams.imageFile = file;\n        presets.forEach(function (p) {\n          return p.classList.remove('selected');\n        });\n        var previewContainer = document.getElementById('image-preview-container');\n        var previewImg = document.getElementById('image-preview');\n        var previewText = document.getElementById('image-preview-text');\n        if (previewContainer && previewImg && previewText) {\n          previewImg.src = reader.result;\n          previewText.textContent = \"\\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F: \".concat(file.name);\n          previewContainer.style.display = 'block';\n        }\n        if (instantUpdate) {\n          (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n        }\n        if (onStateChange) onStateChange(puzzleParams);\n      };\n      reader.readAsDataURL(file);\n    } else {\n      if (puzzleParams.selectedImage && puzzleParams.selectedImage.startsWith('data:image')) {\n        puzzleParams.selectedImage = null;\n        puzzleParams.imageFile = null;\n        var previewContainer = document.getElementById('image-preview-container');\n        if (previewContainer) previewContainer.style.display = 'none';\n        if (instantUpdate) puzzleContainer.innerHTML = '<p>Выберите изображение</p>';\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    }\n  };\n  customInput.removeEventListener('change', customInput.changeHandler);\n  customInput.addEventListener('change', customImageHandler);\n  customInput.changeHandler = customImageHandler;\n\n  // Пресеты\n  presets.forEach(function (preset) {\n    var presetClickHandler = function presetClickHandler() {\n      presets.forEach(function (p) {\n        return p.classList.remove('selected');\n      });\n      preset.classList.add('selected');\n      if (puzzleParams.selectedImage !== preset.dataset.src) {\n        resetToCreateModeIfNeeded();\n      }\n      puzzleParams.selectedImage = preset.dataset.src;\n      puzzleParams.isPreset = true;\n      puzzleParams.imageFile = null;\n      customInput.value = '';\n      var previewContainer = document.getElementById('image-preview-container');\n      if (previewContainer) previewContainer.style.display = 'none';\n      if (instantUpdate) {\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    };\n    preset.removeEventListener('click', preset.clickHandler);\n    preset.addEventListener('click', presetClickHandler);\n    preset.clickHandler = presetClickHandler;\n  });\n\n  // Сложность (размер сетки)\n  var difficultyHandler = function difficultyHandler(e) {\n    var newSize = parseInt(e.target.value, 10);\n    if (newSize !== puzzleParams.gridSize) {\n      resetToCreateModeIfNeeded();\n      puzzleParams.gridSize = newSize;\n      puzzleParams.piecePositions = [];\n      console.log(\"\\u0420\\u0430\\u0437\\u043C\\u0435\\u0440 \\u0441\\u0435\\u0442\\u043A\\u0438 \\u0438\\u0437\\u043C\\u0435\\u043D\\u0435\\u043D \\u043D\\u0430 \".concat(newSize, \", \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u0438 \\u043E\\u0447\\u0438\\u0449\\u0435\\u043D\\u044B.\"));\n      if (instantUpdate) {\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, false);\n      }\n      if (onStateChange) onStateChange(puzzleParams);\n    }\n  };\n  difficultySelect.removeEventListener('change', difficultySelect.changeHandler);\n  difficultySelect.addEventListener('change', difficultyHandler);\n  difficultySelect.changeHandler = difficultyHandler;\n\n  // Кнопка \"Начать игру\"\n  if (startBtn) {\n    var startHandler = function startHandler() {\n      if (!puzzleParams.selectedImage) {\n        alert(\"Пожалуйста, выберите или загрузите изображение.\");\n        return;\n      }\n      var useLoadedPositions = puzzleParams.piecePositions && puzzleParams.piecePositions.length === puzzleParams.gridSize * puzzleParams.gridSize;\n      (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(puzzleContainer, puzzleParams, message, useLoadedPositions);\n      if (onStateChange) {\n        onStateChange(puzzleParams);\n      }\n    };\n    startBtn.removeEventListener('click', startBtn.clickHandler);\n    startBtn.addEventListener('click', startHandler);\n    startBtn.clickHandler = startHandler;\n  }\n  console.log(\"Настройка элементов управления пазлом завершена.\");\n}\n\n/**\r\n * Инициализирует интерфейс и логику для отдельной страницы пазла.\r\n * Эта функция находит все необходимые элементы управления на странице, настраивает их\r\n * с помощью `setupPuzzleControls` и инициализирует функции сохранения/загрузки\r\n * с помощью `initSaveLoadFeatures`. Пазл создается по нажатию кнопки \"Начать игру\".\r\n */\nfunction createPuzzleSeparately() {\n  var _getPuzzleParts = (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.getPuzzleParts)(),\n    _getPuzzleParts2 = _slicedToArray(_getPuzzleParts, 3),\n    localPuzzleParams = _getPuzzleParts2[0],\n    puzzleContainer = _getPuzzleParts2[1],\n    message = _getPuzzleParts2[2];\n  localPuzzleParams.onWhiteboard = false;\n  localPuzzleParams.name = \"\";\n  localPuzzleParams.id = null;\n  localPuzzleParams.ws = null;\n  var wrapper = document.getElementById('puzzle-wrapper');\n  if (!wrapper) {\n    console.error(\"#puzzle-wrapper not found!\");\n    return;\n  }\n  wrapper.innerHTML = '';\n  wrapper.appendChild(puzzleContainer);\n  wrapper.appendChild(message);\n\n  // Находим контролы на странице игры\n  var customInput = document.getElementById('custom-image');\n  var difficultySelect = document.getElementById('difficulty');\n  var presetsNodeList = document.querySelectorAll('.preset');\n  var startBtn = document.getElementById('start-game');\n  var puzzleNameInput = document.getElementById('puzzle-name');\n  var saveButton = document.getElementById('save-puzzle-btn');\n  var loadButton = document.getElementById('load-puzzle-btn');\n  var loadModal = document.getElementById('load-puzzle-modal');\n  var loadListContainer = document.getElementById('load-list-container');\n  var loadConfirmBtn = document.getElementById('load-confirm-btn');\n  var loadCancelBtn = document.getElementById('load-cancel-btn');\n  if (!customInput || !difficultySelect || !(presetsNodeList !== null && presetsNodeList !== void 0 && presetsNodeList.length) || !startBtn || !puzzleNameInput || !saveButton || !loadButton || !loadModal) {\n    console.error(\"Элементы управления на странице пазлов не найдены!\");\n    return;\n  }\n  var presets = Array.from(presetsNodeList);\n\n  // Настройка обработчиков\n  setupPuzzleControls({\n    customInput: customInput,\n    presets: presets,\n    difficultySelect: difficultySelect,\n    startBtn: startBtn,\n    puzzleParams: localPuzzleParams,\n    puzzleContainer: puzzleContainer,\n    message: message,\n    instantUpdate: false,\n    onStateChange: function onStateChange(params) {\n      if (params && typeof params.name !== 'undefined') {\n        puzzleNameInput.value = params.name;\n      }\n    },\n    saveBtnRef: saveButton\n  });\n\n  // Собираем текущее состояние пазла данной страницы для сохранения\n  var getPuzzleStateForSeparatePage = function getPuzzleStateForSeparatePage() {\n    localPuzzleParams.name = puzzleNameInput.value.trim();\n    return {\n      name: localPuzzleParams.name,\n      gridSize: localPuzzleParams.gridSize,\n      piecePositions: localPuzzleParams.piecePositions,\n      selectedImage: localPuzzleParams.selectedImage,\n      presetElements: presets,\n      customImageInputEl: customInput\n    };\n  };\n\n  // Применяем загруженное состояние пазла к странице\n  var applyLoadedStateForSeparatePage = function applyLoadedStateForSeparatePage(puzzleData) {\n    console.log(\"Применение загруженного состояния к отдельной странице:\", puzzleData);\n    localPuzzleParams.id = puzzleData.id;\n    localPuzzleParams.gridSize = puzzleData.grid_size;\n    localPuzzleParams.piecePositions = puzzleData.piece_positions || [];\n    localPuzzleParams.name = puzzleData.name;\n    localPuzzleParams.selectedImage = puzzleData.image_url;\n    localPuzzleParams.isPreset = !!puzzleData.preset_path;\n    difficultySelect.value = puzzleData.grid_size;\n    puzzleNameInput.value = puzzleData.name;\n    customInput.value = '';\n    var previewContainer = document.getElementById('image-preview-container');\n    if (previewContainer) previewContainer.style.display = 'none';\n    presets.forEach(function (p) {\n      return p.classList.remove('selected');\n    });\n    if (localPuzzleParams.isPreset) {\n      var found = false;\n      presets.forEach(function (preset) {\n        var presetSrcRelative = (preset.dataset.src || preset.src).replace(window.location.origin, '');\n        var loadedUrlRelative = puzzleData.image_url.replace(window.location.origin, '');\n        if (presetSrcRelative === loadedUrlRelative) {\n          preset.classList.add('selected');\n          found = true;\n        }\n      });\n      if (!found) console.warn(\"Загруженное предустановленное изображение не найдено:\", puzzleData.image_url);\n    } else {\n      // Показываем превью для загруженного пользовательского фото\n      var previewImg = document.getElementById('image-preview');\n      var previewText = document.getElementById('image-preview-text');\n      if (previewContainer && previewImg && previewText && puzzleData.image_url) {\n        previewImg.src = puzzleData.image_url;\n        previewText.textContent = \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E: \".concat(puzzleData.name);\n        previewContainer.style.display = 'block';\n      } else {\n        console.log(\"Загруженное пользовательское изображение:\", puzzleData.image_url);\n      }\n    }\n\n    // Обновляем кнопку \"Сохранить\"\n    if (saveButton) {\n      saveButton.textContent = 'Обновить пазл';\n      saveButton.dataset.action = 'update';\n      saveButton.dataset.puzzleId = puzzleData.id;\n      if (!saveButton.dataset.originalTextCreate) {\n        saveButton.dataset.originalTextCreate = \"Сохранить\";\n      }\n      saveButton.dataset.originalTextUpdate = \"Обновить пазл\";\n    }\n    alert(\"\\u041F\\u0430\\u0437\\u043B \\\"\".concat(puzzleData.name, \"\\\" (\").concat(puzzleData.grid_size, \"x\").concat(puzzleData.grid_size, \") \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D. \\u041D\\u0430\\u0436\\u043C\\u0438\\u0442\\u0435 \\\"\\u041D\\u0430\\u0447\\u0430\\u0442\\u044C \\u0438\\u0433\\u0440\\u0443\\\", \\u0447\\u0442\\u043E\\u0431\\u044B \\u0441\\u043E\\u0431\\u0440\\u0430\\u0442\\u044C \\u0435\\u0433\\u043E.\"));\n    puzzleContainer.innerHTML = '<p>Пазл загружен. Нажмите \"Начать игру\".</p>';\n    message.style.display = 'none';\n  };\n\n  // Инициализируем Save/Load\n  initSaveLoadFeatures(getPuzzleStateForSeparatePage, applyLoadedStateForSeparatePage, {\n    saveButton: saveButton,\n    loadButton: loadButton,\n    loadModal: loadModal,\n    loadListContainer: loadListContainer,\n    loadConfirmBtn: loadConfirmBtn,\n    loadCancelBtn: loadCancelBtn\n  });\n  if (presets.length > 0 && !localPuzzleParams.selectedImage) {\n    presets[0].click();\n  }\n  puzzleContainer.innerHTML = '<p>Выберите настройки и нажмите \"Начать игру\"</p>';\n  message.style.display = 'none';\n  console.log(\"Страница пазла инициализирована\");\n}\n\n/**\r\n * Создает интерактивный пазл внутри игрового контейнера на доске.\r\n * @param {HTMLElement} gameWrapper - Родительский контейнер для пазла\r\n * @param {string | null} boardRoomName - Имя комнаты доски (для URL WebSocket)\r\n * @param {string} gameInstanceId - Уникальный ID этого экземпляра пазла на доске\r\n */\nfunction createPuzzleOnBoard(gameWrapper, boardRoomName, gameInstanceId) {\n  var _getPuzzleParts3 = (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.getPuzzleParts)(),\n    _getPuzzleParts4 = _slicedToArray(_getPuzzleParts3, 3),\n    localPuzzleParams = _getPuzzleParts4[0],\n    puzzleContainer = _getPuzzleParts4[1],\n    message = _getPuzzleParts4[2];\n\n  // Устанавливаем параметры по умолчанию для нового пазла на доске\n  localPuzzleParams.onWhiteboard = true;\n  localPuzzleParams.gameId = gameInstanceId;\n  localPuzzleParams.id = null; // ID из БД (для сохранения/загрузки)\n  localPuzzleParams.boardRoomName = boardRoomName;\n  localPuzzleParams.name = \"\\u041F\\u0430\\u0437\\u043B \".concat(gameInstanceId.split('-')[1] || '');\n  localPuzzleParams.gridSize = 2;\n  localPuzzleParams.selectedImage = null;\n  localPuzzleParams.isPreset = false;\n  localPuzzleParams.piecePositions = [];\n  gameWrapper.puzzleParams = localPuzzleParams;\n  gameWrapper.puzzleContainer = puzzleContainer;\n  gameWrapper.puzzleMessage = message;\n  var closeButton = gameWrapper.querySelector('.paste-game-close');\n  var resizeHandle = gameWrapper.querySelector('.resize-handle');\n  gameWrapper.innerHTML = '';\n  if (closeButton) gameWrapper.appendChild(closeButton);\n  if (resizeHandle) gameWrapper.appendChild(resizeHandle);\n  gameWrapper.appendChild(puzzleContainer);\n  gameWrapper.appendChild(message);\n  puzzleContainer.innerHTML = '<p style=\"text-align: center; padding: 20px;\">Активируйте пазл и выберите настройки в панели справа.</p>';\n  message.style.display = 'none';\n\n  // Инициация WebSocket для этого экземпляра пазла, если boardRoomName предоставлен (т.е. доска синхронизируется)\n  if (boardRoomName && gameInstanceId) {\n    var puzzleWsUrl = \"ws://\".concat(window.location.host, \"/ws/puzzle_on_board/\").concat(boardRoomName, \"/\").concat(gameInstanceId, \"/\");\n    var puzzleWs = new WebSocket(puzzleWsUrl);\n    localPuzzleParams.ws = puzzleWs; // Сохраняем WebSocket в параметрах этого пазла\n    gameWrapper.puzzleWebSocket = puzzleWs; // Сохраняем в gameWrapper для доступа из whiteboard.js (для закрытия)\n\n    puzzleWs.onopen = function () {\n      console.log(\"[PUZZLE INSTANCE: \".concat(gameInstanceId, \"] WebSocket connected to \").concat(puzzleWsUrl));\n    };\n    puzzleWs.onmessage = function (e) {\n      var data = JSON.parse(e.data);\n      console.log(\"[PUZZLE INSTANCE: \".concat(gameInstanceId, \"] WS Received:\"), data);\n      if (data.type === 'puzzle_piece_click') {\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.applyRemotePieceInteraction)(gameWrapper.puzzleContainer, gameWrapper.puzzleParams, data.pieceIndex, gameWrapper.puzzleMessage);\n      } else if (data.type === 'puzzle_state_change') {\n        // Применяем полное состояние, полученное от другого клиента\n        Object.assign(gameWrapper.puzzleParams, data.puzzleState); // Обновляем локальные параметры\n\n        // Обновить UI панели настроек, если этот пазл сейчас активен\n        var activeBoardGame = document.querySelector('.paste-game-wrapper.active-game');\n        if (activeBoardGame === gameWrapper) {\n          var settingsPanel = document.querySelector('.settings-panel');\n          var puzzleNameInput = settingsPanel === null || settingsPanel === void 0 ? void 0 : settingsPanel.querySelector('#puzzle-name');\n          var difficultySelect = settingsPanel === null || settingsPanel === void 0 ? void 0 : settingsPanel.querySelector('#difficulty');\n          if (puzzleNameInput) puzzleNameInput.value = gameWrapper.puzzleParams.name || '';\n          if (difficultySelect) difficultySelect.value = gameWrapper.puzzleParams.gridSize;\n        }\n\n        // Перерисовываем сам пазл с новым состоянием\n        (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(gameWrapper.puzzleContainer, gameWrapper.puzzleParams, gameWrapper.puzzleMessage, true); // true - use existing positions\n      }\n    };\n    puzzleWs.onclose = function (event) {\n      console.log(\"[PUZZLE INSTANCE: \".concat(gameInstanceId, \"] WebSocket disconnected. Code: \").concat(event.code, \", Reason: \").concat(event.reason));\n    };\n    puzzleWs.onerror = function (error) {\n      console.error(\"[PUZZLE INSTANCE: \".concat(gameInstanceId, \"] WebSocket error:\"), error);\n    };\n  } else {\n    // Локальный режим для этого экземпляра пазла (доска не синхронизируется или это локальное добавление)\n    localPuzzleParams.ws = null;\n    gameWrapper.puzzleWebSocket = null;\n    console.log(\"[PUZZLE INSTANCE: \".concat(gameInstanceId, \"] Running in local mode (no WebSocket).\"));\n  }\n  console.log(\"\\u042D\\u043A\\u0437\\u0435\\u043C\\u043F\\u043B\\u044F\\u0440 \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(gameInstanceId, \" \\u0438\\u043D\\u0438\\u0446\\u0438\\u0430\\u043B\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D \\u043D\\u0430 \\u0434\\u043E\\u0441\\u043A\\u0435.\"));\n}\n\n/**\r\n * Настраивает контролы и Save/Load для активного пазла на доске.\r\n * Вызывается из whiteboard.js, когда пазл на доске получает фокус.\r\n * @param {HTMLElement} activeGameWrapper - Активный игровой контейнер пазла.\r\n */\nfunction setupWhiteboardPuzzleSaveLoad(activeGameWrapper) {\n  var _activeGameWrapper$da;\n  console.log(\"Настройка UI и Save/Load для активного пазла на доске:\", activeGameWrapper === null || activeGameWrapper === void 0 || (_activeGameWrapper$da = activeGameWrapper.dataset) === null || _activeGameWrapper$da === void 0 ? void 0 : _activeGameWrapper$da.id);\n  if (!activeGameWrapper || !activeGameWrapper.puzzleParams || !activeGameWrapper.puzzleContainer || !activeGameWrapper.puzzleMessage) {\n    console.warn(\"Активный пазл на доске не найден или не инициализирован (отсутствуют puzzleParams). Настройка UI пропущена.\");\n    return;\n  }\n  var activePuzzleParams = activeGameWrapper.puzzleParams;\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) {\n    console.error(\"Панель настроек не найдена. Не удается настроить пазл на доске.\");\n    return;\n  }\n\n  // Находим контролы на панели настроек доски\n  var puzzleNameInput = settingsPanel.querySelector('#puzzle-name');\n  var customInput = settingsPanel.querySelector('#custom-image');\n  var difficultySelect = settingsPanel.querySelector('#difficulty');\n  var presetsNodeList = settingsPanel.querySelectorAll('.preset');\n  var saveButton = settingsPanel.querySelector('#save-puzzle-btn');\n  var loadButton = settingsPanel.querySelector('#load-puzzle-btn');\n  var startBtnOnPanel = settingsPanel.querySelector('#start-game'); // Кнопка \"Начать игру\" на панели\n\n  var loadModal = document.getElementById('load-puzzle-modal'); // Глобальное модальное окно\n  var loadListContainer = document.getElementById('load-list-container');\n  var loadConfirmBtn = document.getElementById('load-confirm-btn');\n  var loadCancelBtn = document.getElementById('load-cancel-btn');\n  if (!puzzleNameInput || !customInput || !difficultySelect || !(presetsNodeList !== null && presetsNodeList !== void 0 && presetsNodeList.length) || !saveButton || !loadButton) {\n    console.error(\"Ключевые элементы управления пазлом отсутствуют на панели настроек доски!\");\n    return;\n  }\n  var presets = Array.from(presetsNodeList);\n\n  // Кнопка \"Начать игру\" на панели настроек не нужна, т.к. пазл обновляется мгновенно (instantUpdate=true)\n  if (startBtnOnPanel) {\n    startBtnOnPanel.style.display = 'none';\n  }\n\n  // Устанавливаем текст кнопки \"Сохранить\" в зависимости от того, загружен ли пазл\n  if (activePuzzleParams.id && saveButton) {\n    // Если есть ID из БД\n    if (!saveButton.dataset.originalTextUpdate) saveButton.dataset.originalTextUpdate = \"Обновить пазл\";\n    saveButton.textContent = saveButton.dataset.originalTextUpdate;\n    saveButton.dataset.action = 'update';\n    saveButton.dataset.puzzleId = activePuzzleParams.id;\n  } else if (saveButton) {\n    // Новый пазл\n    if (!saveButton.dataset.originalTextCreate) saveButton.dataset.originalTextCreate = \"Сохранить\";\n    saveButton.textContent = saveButton.dataset.originalTextCreate;\n    saveButton.dataset.action = 'create';\n    delete saveButton.dataset.puzzleId;\n  }\n  var handlePuzzleStateChangeForBoard = function handlePuzzleStateChangeForBoard(changedParams) {\n    console.log(\"\\u041F\\u0430\\u0440\\u0430\\u043C\\u0435\\u0442\\u0440\\u044B \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(changedParams.gameId, \" \\u0438\\u0437\\u043C\\u0435\\u043D\\u0435\\u043D\\u044B \\u0447\\u0435\\u0440\\u0435\\u0437 UI:\"), changedParams);\n    // Отправляем полное состояние через WebSocket этого пазла\n    if (changedParams.onWhiteboard && changedParams.ws && changedParams.ws.readyState === WebSocket.OPEN) {\n      changedParams.ws.send(JSON.stringify({\n        type: 'puzzle_state_change',\n        puzzleState: {\n          // Отправляем только необходимые данные\n          gridSize: changedParams.gridSize,\n          piecePositions: changedParams.piecePositions,\n          selectedImage: changedParams.selectedImage,\n          isPreset: changedParams.isPreset,\n          name: changedParams.name,\n          id: changedParams.id\n        }\n      }));\n    } else if (changedParams.onWhiteboard && !changedParams.ws) {\n      console.log(\"[\\u041B\\u043E\\u043A\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0440\\u0435\\u0436\\u0438\\u043C \\u0434\\u043E\\u0441\\u043A\\u0438] \\u0421\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435 \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(changedParams.gameId, \" \\u0438\\u0437\\u043C\\u0435\\u043D\\u0435\\u043D\\u043E, WS \\u043D\\u0435 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u044D\\u043A\\u0437\\u0435\\u043C\\u043F\\u043B\\u044F\\u0440\\u0430.\"));\n    }\n    // Обновляем поле имени на панели, если оно изменилось\n    if (puzzleNameInput && typeof changedParams.name !== 'undefined') {\n      puzzleNameInput.value = changedParams.name;\n    }\n  };\n\n  // Настраиваем контролы на панели (картинка, сложность)\n  setupPuzzleControls({\n    customInput: customInput,\n    presets: presets,\n    difficultySelect: difficultySelect,\n    startBtn: null,\n    puzzleParams: activePuzzleParams,\n    // Передаем параметры активного пазла\n    puzzleContainer: activeGameWrapper.puzzleContainer,\n    message: activeGameWrapper.puzzleMessage,\n    instantUpdate: true,\n    // Изменения настроек применяются и отправляются сразу\n    onStateChange: handlePuzzleStateChangeForBoard,\n    saveBtnRef: saveButton\n  });\n\n  // Инициализируем значения контролов на панели из текущих параметров активного пазла\n  puzzleNameInput.value = activePuzzleParams.name || '';\n  difficultySelect.value = activePuzzleParams.gridSize;\n  customInput.value = '';\n  var previewContainer = settingsPanel.querySelector('#image-preview-container');\n  var previewImg = settingsPanel.querySelector('#image-preview');\n  var previewText = settingsPanel.querySelector('#image-preview-text');\n  presets.forEach(function (p) {\n    return p.classList.remove('selected');\n  });\n  if (previewContainer) previewContainer.style.display = 'none';\n  if (activePuzzleParams.isPreset && activePuzzleParams.selectedImage) {\n    var selectedPresetElement = presets.find(function (p) {\n      return (p.dataset.src || p.src) === activePuzzleParams.selectedImage;\n    });\n    if (selectedPresetElement) selectedPresetElement.classList.add('selected');\n  } else if (!activePuzzleParams.isPreset && activePuzzleParams.selectedImage) {\n    if (previewContainer && previewImg && previewText) {\n      previewImg.src = activePuzzleParams.selectedImage;\n      previewText.textContent = activePuzzleParams.imageFile ? \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E: \".concat(activePuzzleParams.imageFile.name) : activePuzzleParams.name || 'Загруженное изображение';\n      previewContainer.style.display = 'block';\n    }\n  }\n\n  // --- Логика Сохранения/Загрузки для пазла на доске ---\n  var getPuzzleStateForWhiteboard = function getPuzzleStateForWhiteboard() {\n    var currentActiveWrapper = document.querySelector('.paste-game-wrapper.active-game');\n    // Убедимся, что мы работаем с тем же активным пазлом\n    if (!currentActiveWrapper || currentActiveWrapper !== activeGameWrapper || !currentActiveWrapper.puzzleParams) {\n      alert(\"Активный пазл изменился или не найден. Сохранение отменено.\");\n      return null;\n    }\n    var params = currentActiveWrapper.puzzleParams;\n    params.name = puzzleNameInput.value.trim(); // Берем имя с панели\n\n    if (!params.name) {\n      alert(\"Введите название для сохранения.\");\n      puzzleNameInput.focus();\n      return null;\n    }\n\n    // Если пазл еще не создан (нет piecePositions), создаем его перед сохранением\n    // Это также отправит 'puzzle_state_change' с новыми piecePositions\n    if (!params.piecePositions || params.piecePositions.length !== params.gridSize * params.gridSize) {\n      console.log(\"Пазл не инициализирован, создаем его перед сохранением...\");\n      (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(currentActiveWrapper.puzzleContainer, params, currentActiveWrapper.puzzleMessage, false);\n    }\n    // Проверка еще раз, на случай если createPuzzle не сработал или не установил piecePositions\n    if (!params.piecePositions || params.piecePositions.length !== params.gridSize * params.gridSize) {\n      alert(\"Ошибка: Не удалось инициализировать элементы пазла для сохранения.\");\n      return null;\n    }\n    return {\n      // Данные, необходимые для API сохранения\n      id: params.id,\n      name: params.name,\n      gridSize: params.gridSize,\n      piecePositions: params.piecePositions,\n      // массив индексов\n      selectedImage: params.selectedImage,\n      // URL или DataURL\n      // presetElements и customImageInputEl нужны для initSaveLoadFeatures, чтобы определить тип файла\n      presetElements: presets,\n      // Элементы пресетов с панели настроек\n      customImageInputEl: customInput // Элемент input type=file с панели\n    };\n  };\n  var applyLoadedStateForWhiteboard = function applyLoadedStateForWhiteboard(loadedDbPuzzleData) {\n    var currentActiveWrapper = document.querySelector('.paste-game-wrapper.active-game');\n    if (!currentActiveWrapper || currentActiveWrapper !== activeGameWrapper || !currentActiveWrapper.puzzleParams) {\n      alert(\"Активный пазл изменился или не найден. Загрузка отменена.\");\n      return;\n    }\n    var targetParams = currentActiveWrapper.puzzleParams;\n    console.log(\"Применение загруженного состояния (из БД) к пазлу на доске:\", loadedDbPuzzleData);\n    targetParams.id = loadedDbPuzzleData.id;\n    targetParams.name = loadedDbPuzzleData.name;\n    targetParams.gridSize = loadedDbPuzzleData.grid_size;\n    targetParams.piecePositions = loadedDbPuzzleData.piece_positions || [];\n    targetParams.selectedImage = loadedDbPuzzleData.image_url; // Полный URL изображения\n    targetParams.isPreset = !!loadedDbPuzzleData.preset_path;\n    targetParams.imageFile = null; // Сбрасываем файл, т.к. грузим из БД\n\n    // Обновляем UI панели настроек\n    puzzleNameInput.value = targetParams.name;\n    difficultySelect.value = targetParams.gridSize;\n    customInput.value = '';\n\n    // Обновляем кнопку \"Сохранить\" на панели, чтобы она была \"Обновить\"\n    var currentSettingsPanel = document.querySelector('.settings-panel');\n    if (currentSettingsPanel) {\n      var currentSaveButton = currentSettingsPanel.querySelector('#save-puzzle-btn');\n      if (currentSaveButton) {\n        currentSaveButton.textContent = currentSaveButton.dataset.originalTextUpdate || 'Обновить пазл';\n        currentSaveButton.dataset.action = 'update';\n        currentSaveButton.dataset.puzzleId = loadedDbPuzzleData.id;\n      }\n    }\n    (0,_puzzle_logic_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzle)(currentActiveWrapper.puzzleContainer, targetParams, currentActiveWrapper.puzzleMessage, true); // true - use existing (loaded) positions\n\n    if (targetParams.onWhiteboard && targetParams.ws && targetParams.ws.readyState === WebSocket.OPEN) {\n      console.log(\"[APPLY LOADED] \\u041E\\u0442\\u043F\\u0440\\u0430\\u0432\\u043A\\u0430 \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043D\\u043E\\u0433\\u043E \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(targetParams.gameId));\n      targetParams.ws.send(JSON.stringify({\n        type: 'puzzle_state_change',\n        puzzleState: {\n          gridSize: targetParams.gridSize,\n          piecePositions: targetParams.piecePositions,\n          selectedImage: targetParams.selectedImage,\n          isPreset: targetParams.isPreset,\n          name: targetParams.name,\n          id: targetParams.id\n        }\n      }));\n    } else if (targetParams.onWhiteboard && !targetParams.ws) {\n      console.log(\"[APPLY LOADED - \\u041B\\u043E\\u043A\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0440\\u0435\\u0436\\u0438\\u043C \\u0434\\u043E\\u0441\\u043A\\u0438] \\u0421\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435 \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(targetParams.gameId, \" \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E.\"));\n      // Локальное обновление уже произошло через createPuzzle.\n    }\n    alert(\"\\u041F\\u0430\\u0437\\u043B \\\"\".concat(loadedDbPuzzleData.name, \"\\\" \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D \\u0432 \\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043D\\u0442\\u0435\\u0439\\u043D\\u0435\\u0440.\"));\n  };\n  initSaveLoadFeatures(getPuzzleStateForWhiteboard, applyLoadedStateForWhiteboard, {\n    saveButton: saveButton,\n    loadButton: loadButton,\n    loadModal: loadModal,\n    loadListContainer: loadListContainer,\n    loadConfirmBtn: loadConfirmBtn,\n    loadCancelBtn: loadCancelBtn\n  });\n  console.log(\"UI и Save/Load для активного пазла на доске успешно настроены.\");\n}\n\n//# sourceURL=webpack://frontend/./puzzle/index.js?");

/***/ }),

/***/ "./puzzle/puzzle-logic.js":
/*!********************************!*\
  !*** ./puzzle/puzzle-logic.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyRemotePieceInteraction: () => (/* binding */ applyRemotePieceInteraction),\n/* harmony export */   checkVictory: () => (/* binding */ checkVictory),\n/* harmony export */   createPuzzle: () => (/* binding */ createPuzzle),\n/* harmony export */   getPuzzleParts: () => (/* binding */ getPuzzleParts),\n/* harmony export */   handlePieceClick: () => (/* binding */ handlePieceClick),\n/* harmony export */   placePieces: () => (/* binding */ placePieces),\n/* harmony export */   updatePuzzleImage: () => (/* binding */ updatePuzzleImage)\n/* harmony export */ });\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\r\n * Генерирует базовые компоненты для пазла\r\n * @returns {Array} [params, container, message] - Параметры, контейнер и сообщение\r\n */\nfunction getPuzzleParts() {\n  // Параметры пазла по умолчанию\n  var puzzleParams = {\n    gridSize: 2,\n    // Размер сетки (2x2)\n    piecePositions: [],\n    // Позиции элементов\n    selectedImage: images + '/british-cat.jpg',\n    // Изображение по умолчанию\n    selectedPiece: null,\n    // Локально выбранный кусок для текущего пользователя\n    remoteSelectedPiece: null,\n    // Кусок, \"выбранный\" удаленным пользователем (для обмена)\n    onWhiteboard: false,\n    // Флаг, что пазл на доске\n    gameId: null,\n    // Уникальный ID экземпляра пазла на доске\n    boardRoomName: null,\n    // Имя комнаты доски\n    ws: null,\n    // WebSocket соединение для этого экземпляра пазла\n    name: \"Пазл\",\n    // Имя пазла (для сохранения)\n    id: null,\n    // ID пазла из БД (после сохранения/загрузки)\n    isPreset: false,\n    // Является ли изображение пресетом\n    imageFile: null // Для загрузки пользовательских фото\n  };\n  var puzzleContainer = createPuzzleContainer();\n  var message = createGameMessage();\n  return [puzzleParams, puzzleContainer, message];\n}\n\n/**\r\n * Создает пазл в указанном контейнере\r\n * @param {HTMLElement} puzzleContainer - Контейнер для элементов\r\n * @param {Object} puzzleParams - Параметры пазла\r\n * @param {HTMLElement} message - Элемент для отображения сообщений\r\n * @param {boolean} useExistingPositions - Если true, использует puzzleParams.piecePositions, иначе генерирует новые\r\n */\nfunction createPuzzle(puzzleContainer, puzzleParams, message) {\n  var useExistingPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  puzzleContainer.innerHTML = '';\n  message.style.display = 'none';\n  if (!puzzleParams.selectedImage) {\n    puzzleContainer.innerHTML = '<p style=\"text-align: center; padding: 10px;\">Выберите изображение в настройках.</p>';\n    return; // Не создаем пазл без изображения\n  }\n\n  // Генерируем новые позиции только если не используем существующие\n  if (!useExistingPositions || !puzzleParams.piecePositions || puzzleParams.piecePositions.length !== puzzleParams.gridSize * puzzleParams.gridSize) {\n    console.log(\"\\u0413\\u0435\\u043D\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F \\u043D\\u043E\\u0432\\u044B\\u0445 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(puzzleParams.gameId || '(отдельный)', \" (\\u0440\\u0430\\u0437\\u043C\\u0435\\u0440 \").concat(puzzleParams.gridSize, \"x\").concat(puzzleParams.gridSize, \").\"));\n    puzzleParams.piecePositions = shuffle(_toConsumableArray(Array(puzzleParams.gridSize * puzzleParams.gridSize).keys()));\n  } else {\n    console.log(\"\\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u0445 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(puzzleParams.gameId || '(отдельный)', \".\"));\n  }\n\n  // Создание элементов пазла\n  var _loop = function _loop() {\n    var piece = document.createElement('div');\n    piece.classList.add('puzzle-piece');\n    // data-index всегда соответствует оригинальному индексу куска (0..N-1)\n    piece.setAttribute('data-index', i);\n\n    // Расчет размеров элемента\n    var percent = 100 / puzzleParams.gridSize;\n    piece.style.width = \"\".concat(percent, \"%\");\n    piece.style.height = \"\".concat(percent, \"%\");\n    piece.style.backgroundSize = \"\".concat(puzzleParams.gridSize * 100, \"% \").concat(puzzleParams.gridSize * 100, \"%\");\n\n    // Обработчик клика на элемент\n    piece.addEventListener('click', function () {\n      return handlePieceClick(puzzleContainer, puzzleParams, piece, message);\n    });\n    puzzleContainer.appendChild(piece);\n  };\n  for (var i = 0; i < puzzleParams.gridSize * puzzleParams.gridSize; i++) {\n    _loop();\n  }\n\n  // Установка фона и расстановка по местам\n  updatePuzzleImage(puzzleContainer, puzzleParams);\n\n  // Отправка состояния, если это пазл на доске, WS есть, и это не обновление от другого клиента\n  // (useExistingPositions = true обычно означает, что состояние пришло по WS)\n  if (puzzleParams.onWhiteboard && puzzleParams.ws && puzzleParams.ws.readyState === WebSocket.OPEN && !useExistingPositions) {\n    console.log(\"[PUZZLE-LOGIC] \\u041E\\u0442\\u043F\\u0440\\u0430\\u0432\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(puzzleParams.gameId, \" \\u043F\\u043E\\u0441\\u043B\\u0435 \\u0441\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u044F/\\u0441\\u0431\\u0440\\u043E\\u0441\\u0430.\"));\n    puzzleParams.ws.send(JSON.stringify({\n      type: 'puzzle_state_change',\n      puzzleState: {\n        gridSize: puzzleParams.gridSize,\n        piecePositions: puzzleParams.piecePositions,\n        selectedImage: puzzleParams.selectedImage,\n        isPreset: puzzleParams.isPreset,\n        name: puzzleParams.name,\n        id: puzzleParams.id\n      }\n    }));\n  }\n}\n\n/**\r\n * Обновляет фоновое изображение и расставляет элементы пазла\r\n * @param {HTMLElement} puzzleContainer - Контейнер с элементами пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n */\nfunction updatePuzzleImage(puzzleContainer, puzzleParams) {\n  if (!puzzleParams.selectedImage) return; // Ничего не делаем без изображения\n\n  var pieces = puzzleContainer.querySelectorAll('.puzzle-piece');\n  pieces.forEach(function (piece) {\n    var originalIndex = parseInt(piece.dataset.index, 10);\n    piece.style.backgroundImage = \"url(\\\"\".concat(puzzleParams.selectedImage, \"\\\")\");\n    var row = Math.floor(originalIndex / puzzleParams.gridSize);\n    var col = originalIndex % puzzleParams.gridSize;\n    piece.style.backgroundPosition = \"\".concat(col * -100, \"% \").concat(row * -100, \"%\");\n  });\n  placePieces(puzzleContainer, puzzleParams);\n}\n\n// Создание контейнера для пазлов\nfunction createPuzzleContainer() {\n  var container = document.createElement('div');\n  container.classList.add('puzzle-container');\n  return container;\n}\n\n/**\r\n * Располагает элементы пазла в соответствии с текущими позициями\r\n * @param {HTMLElement} puzzleContainer - Контейнер пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n */\nfunction placePieces(puzzleContainer, puzzleParams) {\n  var pieces = Array.from(puzzleContainer.querySelectorAll('.puzzle-piece'));\n  var gridPositions = [];\n  var percent = 100 / puzzleParams.gridSize;\n\n  // Генерация сетки\n  for (var row = 0; row < puzzleParams.gridSize; row++) {\n    for (var col = 0; col < puzzleParams.gridSize; col++) {\n      gridPositions.push([col * percent, row * percent]);\n    }\n  }\n\n  // Распределение элементов по позициям\n  pieces.forEach(function (piece, domOrderIndex) {\n    var targetGridCellIndex = puzzleParams.piecePositions[domOrderIndex];\n    if (targetGridCellIndex !== undefined && gridPositions[targetGridCellIndex]) {\n      var _gridPositions$target = _slicedToArray(gridPositions[targetGridCellIndex], 2),\n        x = _gridPositions$target[0],\n        y = _gridPositions$target[1];\n      piece.style.left = \"\".concat(x, \"%\");\n      piece.style.top = \"\".concat(y, \"%\");\n    } else {\n      console.error(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u0440\\u0430\\u0441\\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u043A\\u0438: \\u0434\\u043B\\u044F \\u043A\\u0443\\u0441\\u043A\\u0430 \".concat(domOrderIndex, \" \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D\\u0430 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u044F \").concat(targetGridCellIndex, \" \\u0432 piecePositions \\u0438\\u043B\\u0438 gridPositions.\"));\n    }\n  });\n}\n\n/**\r\n * Алгоритм Фишера-Йетса для перемешивания массива\r\n * @param {Array} array - Исходный массив\r\n * @returns {Array} Перемешанный массив\r\n */\nfunction shuffle(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var _ref = [array[j], array[i]];\n    array[i] = _ref[0];\n    array[j] = _ref[1];\n  }\n  return array;\n}\n\n/**\r\n * Обрабатывает клик на элементе пазла\r\n * Для пазлов на доске отправляет событие через WebSocket.\r\n * Локально обрабатывает UI выделения. Обмен кусками для синхронизируемых пазлов происходит при получении ответа.\r\n * @param {HTMLElement} puzzleContainer - Контейнер пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n * @param {HTMLElement} pieceDomElement - Кликнутый DOM-элемент куска\r\n * @param {HTMLElement} message - Элемент сообщения\r\n */\nfunction handlePieceClick(puzzleContainer, puzzleParams, pieceDomElement, message) {\n  var clickedPieceDataIndex = parseInt(pieceDomElement.dataset.index, 10);\n\n  // Отправляем действие по WebSocket этого пазла, если это пазл на доске и WS есть\n  if (puzzleParams.onWhiteboard && puzzleParams.ws && puzzleParams.ws.readyState === WebSocket.OPEN) {\n    puzzleParams.ws.send(JSON.stringify({\n      type: 'puzzle_piece_click',\n      pieceIndex: clickedPieceDataIndex // Отправляем data-index оригинального куска\n    }));\n  }\n\n  // Локальная обработка UI (выделение) и логики (если не пазл на доске или WS нет)\n  if (!puzzleParams.selectedPiece) {\n    // Первый локальный клик\n    puzzleParams.selectedPiece = pieceDomElement;\n    pieceDomElement.style.outline = '2px solid red';\n  } else if (puzzleParams.selectedPiece === pieceDomElement) {\n    // Клик по уже выделенному (отмена)\n    pieceDomElement.style.outline = '';\n    puzzleParams.selectedPiece = null;\n  } else {\n    // Второй локальный клик (по другому куску)\n    // Если это не пазл на доске с активным WS, то делаем обмен локально.\n    // Если это пазл на доске с WS, то обмен произойдет при получении сообщения от puzzleWs.onmessage -> applyRemotePieceInteraction.\n    if (!puzzleParams.onWhiteboard || !puzzleParams.ws || puzzleParams.ws.readyState !== WebSocket.OPEN) {\n      swapPiecesAndUpdate(puzzleContainer, puzzleParams, puzzleParams.selectedPiece, pieceDomElement);\n      checkVictory(puzzleParams, message); // Проверка победы только для локальных изменений\n    }\n    // В любом случае снимаем локальное UI выделение после второго клика\n    if (puzzleParams.selectedPiece) {\n      puzzleParams.selectedPiece.style.outline = '';\n    }\n    puzzleParams.selectedPiece = null;\n  }\n}\n\n// Вспомогательная функция для обмена кусками (только меняет piecePositions и вызывает placePieces)\nfunction swapPiecesAndUpdate(puzzleContainer, puzzleParams, p1Dom, p2Dom) {\n  var pieces = Array.from(puzzleContainer.querySelectorAll('.puzzle-piece'));\n  var domIndex1 = pieces.indexOf(p1Dom);\n  var domIndex2 = pieces.indexOf(p2Dom);\n  if (domIndex1 === -1 || domIndex2 === -1) {\n    console.error(\"Один из элементов для обмена не найден в DOM-контейнере пазла.\");\n    return;\n  }\n\n  // Меняем местами значения в piecePositions, соответствующие этим DOM-элементам\n  var _ref2 = [puzzleParams.piecePositions[domIndex2], puzzleParams.piecePositions[domIndex1]];\n  puzzleParams.piecePositions[domIndex1] = _ref2[0];\n  puzzleParams.piecePositions[domIndex2] = _ref2[1];\n  placePieces(puzzleContainer, puzzleParams); // Перерисовываем пазл с новыми позициями\n}\n\n/**\r\n * Применяет \"удаленное\" взаимодействие с куском (клик от другого пользователя).\r\n * Вызывается из puzzleWs.onmessage в puzzle/index.js.\r\n * @param {HTMLElement} puzzleContainer - Контейнер пазла\r\n * @param {Object} puzzleParams - Параметры пазла\r\n * @param {number} pieceDataIndexToInteract - data-index куска, с которым взаимодействуют\r\n * @param {HTMLElement} message - Элемент для сообщений\r\n */\nfunction applyRemotePieceInteraction(puzzleContainer, puzzleParams, pieceDataIndexToInteract, message) {\n  var pieces = Array.from(puzzleContainer.querySelectorAll('.puzzle-piece'));\n  var targetPieceDom = pieces.find(function (p) {\n    return parseInt(p.dataset.index, 10) === pieceDataIndexToInteract;\n  });\n  if (!targetPieceDom) {\n    console.warn(\"[REMOTE] \\u041A\\u0443\\u0441\\u043E\\u043A \\u0441 data-index \".concat(pieceDataIndexToInteract, \" \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D \\u0432 \\u043F\\u0430\\u0437\\u043B\\u0435 \").concat(puzzleParams.gameId, \".\"));\n    return;\n  }\n\n  // Логика для удаленного взаимодействия:\n  // Если еще не было \"удаленно выбранного\" куска, запоминаем этот.\n  // Если кликнули по \"удаленно выбранному\", сбрасываем выбор.\n  // Если кликнули по другому, производим обмен.\n  if (!puzzleParams.remoteSelectedPiece) {\n    puzzleParams.remoteSelectedPiece = targetPieceDom;\n    // Временное UI выделение для \"удаленно\" выбранного куска\n    targetPieceDom.style.outline = '2px solid blue';\n  } else if (puzzleParams.remoteSelectedPiece === targetPieceDom) {\n    targetPieceDom.style.outline = '';\n    puzzleParams.remoteSelectedPiece = null;\n  } else {\n    // Второй \"удаленный\" клик - производим обмен\n    if (puzzleParams.remoteSelectedPiece) {\n      puzzleParams.remoteSelectedPiece.style.outline = '';\n    }\n    swapPiecesAndUpdate(puzzleContainer, puzzleParams, puzzleParams.remoteSelectedPiece, targetPieceDom);\n    puzzleParams.remoteSelectedPiece = null; // Сброс\n    checkVictory(puzzleParams, message); // Проверяем победу после удаленного обмена\n  }\n}\nfunction checkVictory(puzzleParams, message) {\n  if (!puzzleParams || !puzzleParams.piecePositions) return; // Защита от ошибок\n  var isVictory = puzzleParams.piecePositions.every(function (val, idx) {\n    return val === idx;\n  });\n  if (isVictory) {\n    if (message) message.style.display = 'block';\n    console.log(\"\\u041F\\u0430\\u0437\\u043B \".concat(puzzleParams.gameId || '(отдельный)', \" \\u0441\\u043E\\u0431\\u0440\\u0430\\u043D!\"));\n  } else {\n    if (message) message.style.display = 'none';\n  }\n}\n\n// Создание сообщение о победе\nfunction createGameMessage() {\n  var message = document.createElement('div');\n  message.id = 'game-message';\n  message.style.display = 'none';\n  message.textContent = 'Поздравляем! Вы собрали пазл!';\n  return message;\n}\n\n//# sourceURL=webpack://frontend/./puzzle/puzzle-logic.js?");

/***/ }),

/***/ "./whiteboard.js":
/*!***********************!*\
  !*** ./whiteboard.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./puzzle/index.js */ \"./puzzle/index.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n// Получение элементов в случае если мы на странице видеозвонка\nvar videosElement = document.getElementById('videos');\nvar roomName = videosElement ? videosElement.dataset.roomName : null;\n\n// Получение ссылок на элементы canvas\nvar imageCanvas = document.getElementById('image-layer');\nvar drawCanvas = document.getElementById('draw-layer');\n\n// Контексты рисования\nvar imageCtx = imageCanvas.getContext('2d');\nvar drawCtx = drawCanvas.getContext('2d');\n\n// Состояние приложения\nvar drawing = false; // Флаг процесса рисования\nvar prev = {}; // Предыдущие координаты курсора\n\nvar imagesList = []; // Список загруженных изображений\nvar activeImage = null; // Активное изображение для перемещения/удаления\nvar nextImageId = 0; // Счетчик для уникальных ID изображений\nvar imageUpdateScheduled = false;\nvar nextGameElementId = 0; // Счетчик для ID игровых элементов\nvar gameElements = {}; // Карта для хранения ссылок на DOM элементы игр: { id: element }\nvar gameElementUpdateScheduled = false;\nvar dragOffset = {\n  x: 0,\n  y: 0\n}; // Смещение при перетаскивании\nvar isResizing = false; // Флаг изменения размера (для изображений на canvas)\nvar isDragging = false; // Флаг перетаскивания (для изображений на canvas)\n\nvar currentTool = 'pen'; // Текущий инструмент\nvar currentLineWidth = 2; // Толщина линии\nvar currentColor = '#000000'; // Цвет по умолчанию\n\n// Функция для получения координат мыши на канвасе\nfunction getMousePos(canvas, evt) {\n  var rect = canvas.getBoundingClientRect();\n  return {\n    x: evt.clientX - rect.left,\n    y: evt.clientY - rect.top\n  };\n}\n\n// Инициализация WebSocket соединения\nvar ws;\nvar isWebSocketActive = !!roomName;\nif (isWebSocketActive) {\n  console.log(\"\\u0414\\u043E\\u0441\\u043A\\u0430 \\u043F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u043A \\u043A\\u043E\\u043C\\u043D\\u0430\\u0442\\u0435: \".concat(roomName));\n  ws = new WebSocket(\"ws://\".concat(window.location.host, \"/ws/whiteboard/\").concat(roomName, \"/\"));\n\n  // Обработчик входящих сообщений\n  ws.onmessage = function (e) {\n    var data = JSON.parse(e.data);\n\n    // Рисование\n    if (data.type === \"draw\") {\n      var x0 = data.x0,\n        y0 = data.y0,\n        x1 = data.x1,\n        y1 = data.y1,\n        color = data.color,\n        lineWidth = data.lineWidth,\n        tool = data.tool;\n      drawLine(drawCtx, x0, y0, x1, y1, color, lineWidth, tool);\n    } else if (data.type === 'image') {\n      // Работа с изображениями\n      var img = new Image();\n      img.onload = function () {\n        var imageId = data.id !== undefined ? data.id : nextImageId++;\n        var imageObj = {\n          id: imageId,\n          img: img,\n          x: data.x !== undefined ? data.x : 50,\n          y: data.y !== undefined ? data.y : 50,\n          width: data.width !== undefined ? data.width : 200,\n          height: data.height !== undefined ? data.height : 200,\n          dataURL: data.dataURL\n        };\n        if (!imagesList.find(function (item) {\n          return item.id === imageObj.id;\n        })) {\n          imagesList.push(imageObj);\n          // Убедимся, что nextImageId всегда больше существующих ID, если ID пришел от сервера\n          if (data.id !== undefined && data.id >= nextImageId) {\n            nextImageId = data.id + 1;\n          }\n        } else {\n          var existingImgIndex = imagesList.findIndex(function (item) {\n            return item.id === imageObj.id;\n          });\n          if (existingImgIndex !== -1) {\n            imagesList[existingImgIndex] = _objectSpread(_objectSpread({}, imagesList[existingImgIndex]), imageObj);\n          }\n        }\n        redrawImages();\n      };\n      img.src = data.dataURL;\n    } else if (data.type === 'clear') {\n      // Очистка доски\n      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);\n      imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n      imagesList = [];\n      activeImage = null;\n      nextImageId = 0;\n      for (var id in gameElements) {\n        if (gameElements.hasOwnProperty(id)) {\n          gameElements[id].remove();\n        }\n      }\n      gameElements = {};\n      nextGameElementId = 0;\n      clearDynamicSettings();\n    } else if (data.type === 'delete_image') {\n      // Удаление изображения\n      imagesList = imagesList.filter(function (imgObj) {\n        return imgObj.id !== data.id;\n      });\n      if (activeImage && activeImage.id === data.id) {\n        activeImage = null;\n      }\n      redrawImages();\n    } else if (data.type === 'move_image' || data.type === 'resize_image') {\n      // Перемещение и/или изменение размера изображения\n      var imgIndex = imagesList.findIndex(function (img) {\n        return img.id === data.id;\n      });\n      if (imgIndex !== -1) {\n        imagesList[imgIndex].x = data.x;\n        imagesList[imgIndex].y = data.y;\n        if (data.type === 'resize_image') {\n          imagesList[imgIndex].width = data.width;\n          imagesList[imgIndex].height = data.height;\n        }\n        if (!imagesList[imgIndex].img.src && data.dataURL) {\n          var newImg = new Image();\n          newImg.onload = function () {\n            imagesList[imgIndex].img = newImg;\n            redrawImages();\n          };\n          newImg.src = data.dataURL;\n        } else {\n          redrawImages();\n        }\n      } else if (data.dataURL) {\n        // Если изображения нет, создаем его\n        var _img = new Image();\n        _img.onload = function () {\n          var imageObj = {\n            id: data.id,\n            img: _img,\n            x: data.x,\n            y: data.y,\n            width: data.width,\n            height: data.height,\n            dataURL: data.dataURL\n          };\n          imagesList.push(imageObj);\n          if (data.id !== undefined && data.id >= nextImageId) {\n            nextImageId = data.id + 1;\n          }\n          redrawImages();\n        };\n        _img.src = data.dataURL;\n      }\n    } else if (data.type === 'image_drag_update') {\n      var _imgIndex = imagesList.findIndex(function (img) {\n        return img.id === data.id;\n      });\n      if (_imgIndex !== -1) {\n        imagesList[_imgIndex].x = data.x;\n        imagesList[_imgIndex].y = data.y;\n        redrawImages();\n      }\n    } else if (data.type === 'image_resize_update') {\n      var _imgIndex2 = imagesList.findIndex(function (img) {\n        return img.id === data.id;\n      });\n      if (_imgIndex2 !== -1) {\n        imagesList[_imgIndex2].x = data.x;\n        imagesList[_imgIndex2].y = data.y;\n        imagesList[_imgIndex2].width = data.width;\n        imagesList[_imgIndex2].height = data.height;\n        redrawImages();\n      }\n    } else if (data.type === 'add_game_element') {\n      // Добавление игры на доску\n      if (!gameElements[data.id]) {\n        var gameWrapper = createGameElementLocally(data.id, data.gameName, data.x, data.y, data.width, data.height);\n        if (gameWrapper && data.gameName === \"puzzles\") {\n          if (!gameWrapper.dataset.puzzleInitialized) {\n            (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzleOnBoard)(gameWrapper, roomName, data.id);\n            gameWrapper.dataset.puzzleInitialized = \"true\";\n          }\n        }\n      }\n      // Обновляем nextGameElementId, чтобы избежать коллизий, если ID пришел от другого клиента\n      var numericId = parseInt(data.id.split('-')[1]);\n      if (!isNaN(numericId) && numericId >= nextGameElementId) {\n        nextGameElementId = numericId + 1;\n      }\n    } else if (data.type === 'delete_game_element') {\n      // Удаление игры с доски\n      var _gameWrapper = gameElements[data.id];\n      if (_gameWrapper) {\n        if (_gameWrapper.puzzleWebSocket && _gameWrapper.puzzleWebSocket.readyState === WebSocket.OPEN) {\n          _gameWrapper.puzzleWebSocket.close();\n          console.log(\"\\u0412\\u0435\\u0431\\u0441\\u043E\\u043A\\u0435\\u0442 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430 \".concat(_gameWrapper.dataset.id, \" \\u0437\\u0430\\u043A\\u0440\\u044B\\u0442.\"));\n        }\n        if (_gameWrapper.classList.contains('active-game')) {\n          clearDynamicSettings();\n        }\n        _gameWrapper.remove();\n        delete gameElements[data.id];\n      }\n    } else if (data.type === 'move_game_element' || data.type === 'game_element_drag_update') {\n      // Перемещение и/или изменение размера gameWrapper\n      var _gameWrapper2 = gameElements[data.id];\n      if (_gameWrapper2) {\n        _gameWrapper2.style.left = data.x + 'px';\n        _gameWrapper2.style.top = data.y + 'px';\n      }\n    } else if (data.type === 'resize_game_element' || data.type === 'game_element_resize_update') {\n      var _gameWrapper3 = gameElements[data.id];\n      if (_gameWrapper3) {\n        _gameWrapper3.style.left = data.x + 'px';\n        _gameWrapper3.style.top = data.y + 'px';\n        _gameWrapper3.style.width = data.width + 'px';\n        _gameWrapper3.style.height = data.height + 'px';\n      }\n    } else if (data.type === 'game_element_focus') {\n      // Выделение активной игры\n      var _gameWrapper4 = gameElements[data.id];\n      if (_gameWrapper4) {\n        document.querySelectorAll('.paste-game-wrapper.active-game').forEach(function (activeWrapper) {\n          if (activeWrapper !== _gameWrapper4) {\n            activeWrapper.classList.remove('active-game');\n            activeWrapper.dataset.settingsUpdated = 'false';\n            activeWrapper.style.borderColor = '';\n            activeWrapper.style.zIndex = '';\n          }\n        });\n        _gameWrapper4.classList.add('active-game');\n        _gameWrapper4.style.borderColor = 'blue';\n        _gameWrapper4.style.zIndex = '100';\n        updateGameSettings(_gameWrapper4.dataset.gameName);\n        _gameWrapper4.dataset.settingsUpdated = 'true';\n        if (_gameWrapper4.dataset.gameName === \"puzzles\") {\n          (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.setupWhiteboardPuzzleSaveLoad)(_gameWrapper4);\n        }\n      }\n    } else if (data.type === 'game_element_blur') {\n      // Удаление выделения\n      var _gameWrapper5 = gameElements[data.id];\n      if (_gameWrapper5) {\n        _gameWrapper5.classList.remove('active-game');\n        _gameWrapper5.dataset.settingsUpdated = 'false';\n        _gameWrapper5.style.borderColor = '';\n        _gameWrapper5.style.zIndex = '';\n        if (!document.querySelector('.paste-game-wrapper.active-game')) {\n          clearDynamicSettings();\n        }\n      }\n    }\n  };\n  ws.onopen = function () {\n    console.log(\"\\u0412\\u0435\\u0431\\u0441\\u043E\\u043A\\u0435\\u0442 \\u0434\\u043E\\u0441\\u043A\\u0438 \\u043F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0435\\u043D \\u043A \\u043A\\u043E\\u043C\\u043D\\u0430\\u0442\\u0435: \".concat(roomName));\n  };\n  ws.onclose = function () {\n    console.log(\"\\u0412\\u0435\\u0431\\u0441\\u043E\\u043A\\u0435\\u0442 \\u0434\\u043E\\u0441\\u043A\\u0438 \\u043E\\u0442\\u043A\\u043B\\u044E\\u0447\\u0435\\u043D \\u043E\\u0442 \\u043A\\u043E\\u043C\\u043D\\u0430\\u0442\\u044B: \".concat(roomName));\n  };\n  ws.onerror = function (error) {\n    console.error(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u0432\\u0435\\u0431\\u0441\\u043E\\u043A\\u0435\\u0442\\u0430 \\u0434\\u043E\\u0441\\u043A\\u0438 \\u0434\\u043B\\u044F \\u043A\\u043E\\u043C\\u043D\\u0430\\u0442\\u044B \".concat(roomName, \":\"), error);\n  };\n} else {\n  console.warn(\"roomName для доски не найден. Синхронизация будет отключена. Работа в локальном режиме.\");\n  ws = {\n    send: function send(message) {\n      var data = JSON.parse(message);\n      if (data.type === 'add_game_element') {\n        if (!gameElements[data.id]) {\n          var gameWrapper = createGameElementLocally(data.id, data.gameName, data.x, data.y, data.width, data.height);\n          if (gameWrapper && data.gameName === \"puzzles\") {\n            if (!gameWrapper.dataset.puzzleInitialized) {\n              (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzleOnBoard)(gameWrapper);\n              gameWrapper.dataset.puzzleInitialized = \"true\";\n            }\n          }\n        }\n        // Обновляем nextGameElementId\n        var numericId = parseInt(data.id.split('-')[1]);\n        if (!isNaN(numericId) && numericId >= nextGameElementId) {\n          nextGameElementId = numericId + 1;\n        }\n      } else if (data.type === 'delete_game_element') {\n        var _gameWrapper6 = gameElements[data.id];\n        if (_gameWrapper6) {\n          if (_gameWrapper6.classList.contains('active-game')) {\n            clearDynamicSettings();\n          }\n          _gameWrapper6.remove();\n          delete gameElements[data.id];\n        }\n      } else if (data.type === 'game_element_focus') {\n        var _gameWrapper7 = gameElements[data.id];\n        if (_gameWrapper7) {\n          document.querySelectorAll('.paste-game-wrapper.active-game').forEach(function (activeWrapper) {\n            if (activeWrapper !== _gameWrapper7) {\n              activeWrapper.classList.remove('active-game');\n              activeWrapper.dataset.settingsUpdated = 'false';\n              activeWrapper.style.borderColor = '';\n              activeWrapper.style.zIndex = '';\n            }\n          });\n          _gameWrapper7.classList.add('active-game');\n          _gameWrapper7.style.borderColor = 'blue';\n          _gameWrapper7.style.zIndex = '100';\n          updateGameSettings(_gameWrapper7.dataset.gameName);\n          _gameWrapper7.dataset.settingsUpdated = 'true';\n          if (_gameWrapper7.dataset.gameName === \"puzzles\") {\n            (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.setupWhiteboardPuzzleSaveLoad)(_gameWrapper7);\n          }\n        }\n      } else if (data.type === 'game_element_blur') {\n        var _gameWrapper8 = gameElements[data.id];\n        if (_gameWrapper8) {\n          _gameWrapper8.classList.remove('active-game');\n          _gameWrapper8.dataset.settingsUpdated = 'false';\n          _gameWrapper8.style.borderColor = '';\n          _gameWrapper8.style.zIndex = '';\n          if (!document.querySelector('.paste-game-wrapper.active-game')) {\n            clearDynamicSettings();\n          }\n        }\n      }\n    },\n    readyState: WebSocket.CLOSED\n  };\n}\n\n// Инициализация инструментов\ndocument.getElementById('pen_btn').addEventListener('click', function () {\n  currentTool = 'pen';\n  toggleToolButtons('pen_btn');\n  drawCanvas.style.cursor = 'crosshair';\n  clearSelection();\n  var activeGameObject = document.querySelector('.paste-game-wrapper.active-game');\n  if (activeGameObject && activeGameObject.dataset.id && ws.readyState === WebSocket.OPEN) {\n    activeGameObject.classList.remove('active-game');\n    activeGameObject.dataset.settingsUpdated = 'false';\n    activeGameObject.style.borderColor = '';\n    activeGameObject.style.zIndex = '';\n    clearDynamicSettings();\n  }\n});\ndocument.getElementById('eraser_btn').addEventListener('click', function () {\n  currentTool = 'eraser';\n  toggleToolButtons('eraser_btn');\n  drawCanvas.style.cursor = 'crosshair';\n  clearSelection();\n  var activeGameObject = document.querySelector('.paste-game-wrapper.active-game');\n  if (activeGameObject && activeGameObject.dataset.id && ws.readyState === WebSocket.OPEN) {\n    activeGameObject.classList.remove('active-game');\n    activeGameObject.dataset.settingsUpdated = 'false';\n    activeGameObject.style.borderColor = '';\n    activeGameObject.style.zIndex = '';\n    clearDynamicSettings();\n  }\n});\n\n// Обработчики параметров рисования\ndocument.getElementById('colorPicker').addEventListener('input', function (e) {\n  currentColor = e.target.value;\n});\ndocument.getElementById('thickness').addEventListener('input', function (e) {\n  currentLineWidth = parseInt(e.target.value);\n});\n\n/**\r\n * Управляет визуальной активностью кнопок инструментов.\r\n * Убирает класс 'active' со всех кнопок и добавляет его выбранной кнопке.\r\n * @param {string} activeId - ID активной кнопки инструмента\r\n */\nfunction toggleToolButtons(activeId) {\n  document.querySelectorAll('.tool').forEach(function (btn) {\n    return btn.classList.remove('active');\n  });\n  if (activeId && document.getElementById(activeId)) {\n    // Проверка существования элемента\n    document.getElementById(activeId).classList.add('active');\n  }\n}\n\n// Обработчики событий мыши для Canvas\ndrawCanvas.addEventListener('mousedown', function (e) {\n  var _getMousePos = getMousePos(drawCanvas, e),\n    x = _getMousePos.x,\n    y = _getMousePos.y;\n  var clickedImage = getImageAt(x, y);\n  if (!e.target.closest('.paste-game-wrapper')) {\n    var activeGameObject = document.querySelector('.paste-game-wrapper.active-game');\n    if (activeGameObject) {\n      // Если есть активная игра и клик мимо нее, снимаем фокус\n      if (isWebSocketActive && ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({\n          type: 'game_element_blur',\n          id: activeGameObject.dataset.id\n        }));\n      } else if (!isWebSocketActive) {\n        // Локальный режим\n        activeGameObject.classList.remove('active-game');\n        activeGameObject.dataset.settingsUpdated = 'false';\n        activeGameObject.style.borderColor = '';\n        activeGameObject.style.zIndex = '';\n        clearDynamicSettings();\n      }\n    }\n  }\n  if (clickedImage) {\n    // Взаимодействие с изображением на canvas\n    activeImage = clickedImage;\n    redrawImages();\n    if (overResizeHandle(x, y, activeImage)) {\n      isResizing = true;\n      dragOffset.startX = x;\n      dragOffset.startY = y;\n      dragOffset.startImageX = activeImage.x;\n      dragOffset.startImageY = activeImage.y;\n      dragOffset.startWidth = activeImage.width;\n      dragOffset.startHeight = activeImage.height;\n      drawCanvas.style.cursor = 'nwse-resize';\n    } else {\n      isDragging = true;\n      dragOffset.x = x - activeImage.x;\n      dragOffset.y = y - activeImage.y;\n      drawCanvas.style.cursor = 'move';\n    }\n  } else {\n    // Клик на пустом месте canvas\n    if (currentTool === 'pen' || currentTool === 'eraser') {\n      drawing = true;\n      prev = {\n        x: x,\n        y: y\n      };\n      clearSelection();\n      drawCanvas.style.cursor = 'crosshair';\n    } else {\n      clearSelection();\n      drawCanvas.style.cursor = 'default';\n    }\n  }\n});\ndrawCanvas.addEventListener('mouseup', function () {\n  if (drawing) {\n    drawing = false;\n    if (currentTool === 'eraser') {\n      drawCtx.globalCompositeOperation = 'source-over';\n    }\n  }\n  if (isDragging && activeImage) {\n    // Отправляем финальное состояние перемещенного изображения\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({\n        type: 'move_image',\n        id: activeImage.id,\n        x: activeImage.x,\n        y: activeImage.y,\n        dataURL: activeImage.dataURL\n      }));\n    }\n    isDragging = false;\n  }\n  if (isResizing && activeImage) {\n    // Отправляем финальное состояние измененного изображения\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({\n        type: 'resize_image',\n        id: activeImage.id,\n        x: activeImage.x,\n        y: activeImage.y,\n        width: activeImage.width,\n        height: activeImage.height,\n        dataURL: activeImage.dataURL\n      }));\n    }\n    isResizing = false;\n  }\n  imageUpdateScheduled = false;\n});\ndrawCanvas.addEventListener('mousemove', function (e) {\n  var _getMousePos2 = getMousePos(drawCanvas, e),\n    x = _getMousePos2.x,\n    y = _getMousePos2.y;\n  var someonesDraggingDOM = Object.values(gameElements).some(function (el) {\n    return el.isDragging || el.isResizing;\n  }); // Проверка, не тащится ли DOM элемент\n\n  if (drawing && !someonesDraggingDOM) {\n    var current = {\n      x: x,\n      y: y\n    };\n    if (prev.x === current.x && prev.y === current.y) return;\n    var colorForDraw = currentTool === 'pen' ? currentColor : '#000000';\n    var message = {\n      type: 'draw',\n      x0: prev.x,\n      y0: prev.y,\n      x1: current.x,\n      y1: current.y,\n      color: colorForDraw,\n      lineWidth: currentLineWidth,\n      tool: currentTool\n    };\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n    drawLine(drawCtx, prev.x, prev.y, current.x, current.y, colorForDraw, currentLineWidth, currentTool);\n    prev = current;\n  } else if (isDragging && activeImage && !someonesDraggingDOM) {\n    activeImage.x = x - dragOffset.x;\n    activeImage.y = y - dragOffset.y;\n    redrawImages();\n    drawCanvas.style.cursor = 'grabbing';\n    if (!imageUpdateScheduled && ws.readyState === WebSocket.OPEN) {\n      imageUpdateScheduled = true;\n      requestAnimationFrame(function () {\n        if (isDragging && activeImage) {\n          ws.send(JSON.stringify({\n            type: 'image_drag_update',\n            id: activeImage.id,\n            x: activeImage.x,\n            y: activeImage.y\n          }));\n        }\n        imageUpdateScheduled = false;\n      });\n    }\n  } else if (isResizing && activeImage && !someonesDraggingDOM) {\n    var newWidth = dragOffset.startWidth + (x - dragOffset.startX);\n    var newHeight = dragOffset.startHeight + (y - dragOffset.startY);\n    activeImage.width = Math.max(20, newWidth);\n    activeImage.height = Math.max(20, newHeight);\n    redrawImages();\n    drawCanvas.style.cursor = 'nwse-resize';\n    if (!imageUpdateScheduled && ws.readyState === WebSocket.OPEN) {\n      imageUpdateScheduled = true;\n      requestAnimationFrame(function () {\n        if (isResizing && activeImage) {\n          ws.send(JSON.stringify({\n            type: 'image_resize_update',\n            id: activeImage.id,\n            x: activeImage.x,\n            y: activeImage.y,\n            width: activeImage.width,\n            height: activeImage.height\n          }));\n        }\n        imageUpdateScheduled = false;\n      });\n    }\n  } else if (!drawing && !isDragging && !isResizing && !someonesDraggingDOM) {\n    var hoveredImage = getImageAt(x, y);\n    if (hoveredImage && currentTool !== 'pen' && currentTool !== 'eraser') {\n      // Не менять курсор если рисуем\n      if (overResizeHandle(x, y, hoveredImage)) {\n        drawCanvas.style.cursor = 'nwse-resize';\n      } else {\n        drawCanvas.style.cursor = 'move';\n      }\n    } else {\n      drawCanvas.style.cursor = currentTool === 'pen' || currentTool === 'eraser' ? 'crosshair' : 'default';\n    }\n  }\n});\n\n// Обработчик нажатия клавиш для удаления изображения на canvas\nwindow.addEventListener('keydown', function (e) {\n  if (e.key === 'Delete' || e.key === 'Backspace') {\n    if (activeImage && !isInputActive()) {\n      // Удаление изображения на canvas\n      e.preventDefault();\n      deleteImage(activeImage.id);\n    }\n  }\n});\n\n// Проверка: активно ли поле ввода\nfunction isInputActive() {\n  var activeEl = document.activeElement;\n  return activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);\n}\n\n// Удаления изображения с canvas\nfunction deleteImage(imageId) {\n  if (ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify({\n      type: 'delete_image',\n      id: imageId\n    }));\n  }\n  imagesList = imagesList.filter(function (imgObj) {\n    return imgObj.id !== imageId;\n  });\n  if (activeImage && activeImage.id === imageId) {\n    activeImage = null;\n  }\n  redrawImages();\n}\n\n// Снятие выделения с изображения на canvas\nfunction clearSelection() {\n  if (activeImage) {\n    activeImage = null;\n    redrawImages();\n  }\n}\n\n/**\r\n * Рисует линию на заданном контексте.\r\n * @param {CanvasRenderingContext2D} ctx - Контекст рисования\r\n * @param {number} x0 - Начальная координата X\r\n * @param {number} y0 - Начальная координата Y\r\n * @param {number} x1 - Конечная координата X\r\n * @param {number} y1 - Конечная координата Y\r\n * @param {string} color - Цвет линии\r\n * @param {number} lineWidth - Толщина линии\r\n * @param {string} tool - Текущий инструмент ('pen' или 'eraser')\r\n */\nfunction drawLine(ctx, x0, y0, x1, y1, color, lineWidth) {\n  var tool = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'pen';\n  ctx.lineWidth = lineWidth;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  if (tool === 'eraser') {\n    ctx.globalCompositeOperation = 'destination-out';\n  } else {\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.strokeStyle = color;\n  }\n  ctx.beginPath();\n  ctx.moveTo(x0, y0);\n  ctx.lineTo(x1, y1);\n  ctx.stroke();\n}\n\n// Загрузка пользовательских изображений\ndocument.getElementById('img-upload').addEventListener('change', function () {\n  var file = this.files[0];\n  if (!file) return;\n  var reader = new FileReader();\n  reader.onload = function () {\n    var dataURL = reader.result;\n    var imageId = nextImageId++;\n    var img = new Image();\n    img.onload = function () {\n      var imageObj = {\n        id: imageId,\n        img: img,\n        x: 50,\n        y: 50,\n        width: img.naturalWidth > 400 ? 400 : img.naturalWidth,\n        height: img.naturalHeight > 300 ? img.naturalHeight * (400 / img.naturalWidth) : img.naturalHeight,\n        dataURL: dataURL\n      };\n      if (imageObj.width > 400 || imageObj.height > 300) {\n        var aspectRatio = imageObj.width / imageObj.height;\n        if (imageObj.width > imageObj.height) {\n          imageObj.width = 400;\n          imageObj.height = 400 / aspectRatio;\n        } else {\n          imageObj.height = 300;\n          imageObj.width = 300 * aspectRatio;\n        }\n      }\n      imagesList.push(imageObj);\n      redrawImages();\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({\n          type: 'image',\n          id: imageId,\n          dataURL: dataURL,\n          x: imageObj.x,\n          y: imageObj.y,\n          width: imageObj.width,\n          height: imageObj.height\n        }));\n      }\n    };\n    img.onerror = function () {\n      return console.error(\"Ошибка загрузки изображения для dataURL\");\n    };\n    img.src = dataURL;\n  };\n  reader.readAsDataURL(file);\n  this.value = '';\n});\n\n/**\r\n * Очищает доску и сбрасывает загруженные изображения.\r\n */\nfunction clearBoard() {\n  if (isWebSocketActive && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify({\n      type: 'clear'\n    }));\n  } else if (!isWebSocketActive) {\n    // Локальный режим: очищаем сразу\n    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);\n    imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n    imagesList = [];\n    activeImage = null;\n    nextImageId = 0;\n    document.getElementById('img-upload').value = ''; // Сбрасываем input\n\n    for (var id in gameElements) {\n      if (gameElements.hasOwnProperty(id)) {\n        gameElements[id].remove();\n      }\n    }\n    gameElements = {};\n    nextGameElementId = 0;\n    clearDynamicSettings();\n    console.log(\"Доска очищена локально.\");\n  }\n}\ndocument.querySelector(\"#clear_btn\").addEventListener(\"click\", function () {\n  clearBoard();\n});\n\n/**\r\n * Перерисовывает все изображения на слое изображений и отображает маркеры изменения размера.\r\n */\nfunction redrawImages() {\n  imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n  var prevOp = imageCtx.globalCompositeOperation;\n  imageCtx.globalCompositeOperation = 'source-over';\n  imagesList.forEach(function (imgObj) {\n    imageCtx.drawImage(imgObj.img, imgObj.x, imgObj.y, imgObj.width, imgObj.height);\n\n    // Если изображение активно, рисуем рамку выделения и маркеры\n    if (activeImage && activeImage.id === imgObj.id) {\n      imageCtx.strokeStyle = 'blue';\n      imageCtx.lineWidth = 2;\n      imageCtx.strokeRect(imgObj.x - 1, imgObj.y - 1, imgObj.width + 2, imgObj.height + 2);\n      drawResizeHandle(imageCtx, imgObj);\n    }\n  });\n  imageCtx.globalCompositeOperation = prevOp;\n}\n\n// Вспомогательные функции для изображений на canvas\nfunction getImageAt(x, y) {\n  // Перебираем в обратном порядке, чтобы выбрать верхнее изображение, если они накладываются\n  for (var i = imagesList.length - 1; i >= 0; i--) {\n    var img = imagesList[i];\n    if (x >= img.x && x <= img.x + img.width && y >= img.y && y <= img.y + img.height) {\n      return img;\n    }\n  }\n  return null;\n}\nfunction drawResizeHandle(ctx, imgObj) {\n  var size = 10;\n  ctx.fillStyle = '#007bff';\n  ctx.strokeStyle = 'white';\n  ctx.lineWidth = 1;\n  ctx.fillRect(imgObj.x + imgObj.width - size / 2, imgObj.y + imgObj.height - size / 2, size, size);\n  ctx.strokeRect(imgObj.x + imgObj.width - size / 2, imgObj.y + imgObj.height - size / 2, size, size);\n}\nfunction overResizeHandle(x, y, imgObj) {\n  var size = 10;\n  var handleX = imgObj.x + imgObj.width - size / 2;\n  var handleY = imgObj.y + imgObj.height - size / 2;\n  return x >= handleX && x <= handleX + size && y >= handleY && y <= handleY + size;\n}\n\n/**\r\n * Адаптирует размер холста (canvas) под размеры родительского контейнера.\r\n */\nfunction resizeCanvasToDisplaySize() {\n  var wrapper = imageCanvas.parentElement;\n  if (!wrapper) {\n    console.warn(\"Холст не найден\");\n    return;\n  }\n  var width = wrapper.clientWidth;\n  var height = wrapper.clientHeight;\n\n  // Сохраняем текущее содержимое drawCanvas\n  var tempDrawCanvas = document.createElement('canvas');\n  tempDrawCanvas.width = drawCanvas.width;\n  tempDrawCanvas.height = drawCanvas.height;\n  var tempDrawCtx = tempDrawCanvas.getContext('2d');\n  if (drawCanvas.width > 0 && drawCanvas.height > 0) {\n    tempDrawCtx.drawImage(drawCanvas, 0, 0);\n  }\n  imageCanvas.width = width;\n  imageCanvas.height = height;\n  drawCanvas.width = width;\n  drawCanvas.height = height;\n\n  // Восстанавливаем содержимое drawCanvas\n  if (tempDrawCanvas.width > 0 && tempDrawCanvas.height > 0) {\n    // Убедимся, что настройки рисования (цвет, толщина, compositeOperation) не сбились\n    drawCtx.strokeStyle = currentColor;\n    drawCtx.lineWidth = currentLineWidth;\n    drawCtx.lineCap = 'round';\n    drawCtx.lineJoin = 'round';\n    if (currentTool === 'eraser') {\n      drawCtx.globalCompositeOperation = 'destination-out';\n    } else {\n      drawCtx.globalCompositeOperation = 'source-over';\n    }\n    drawCtx.drawImage(tempDrawCanvas, 0, 0);\n  }\n  redrawImages();\n}\nwindow.addEventListener('load', function () {\n  resizeCanvasToDisplaySize();\n  if (document.getElementById('pen_btn')) {\n    toggleToolButtons('pen_btn');\n    currentTool = 'pen'; // Убедимся, что currentTool соответствует\n    drawCanvas.style.cursor = 'crosshair';\n  } else {\n    currentTool = 'select'; // или другое значение по умолчанию, если кнопки pen нет\n    drawCanvas.style.cursor = 'default';\n  }\n});\nwindow.addEventListener('resize', resizeCanvasToDisplaySize);\n\n// Инициализация меню игр\nvar dropdown = document.getElementById(\"game-menu\");\nvar gamesBtn = document.getElementById(\"games_btn\");\nvar gameMenu = document.getElementById(\"game-menu\");\ngamesBtn.addEventListener(\"click\", function () {\n  updategameMenuPos();\n  dropdown.classList.toggle(\"show\");\n});\nwindow.addEventListener(\"resize\", function () {\n  if (dropdown.classList.contains(\"show\")) {\n    updategameMenuPos();\n  }\n});\n\n/**\r\n * Обновляет позицию выпадающего меню игр относительно кнопки.\r\n */\nfunction updategameMenuPos() {\n  var rect = gamesBtn.getBoundingClientRect();\n  gameMenu.style.top = \"\".concat(rect.bottom + window.scrollY, \"px\");\n  gameMenu.style.left = \"\".concat(rect.left + window.scrollX, \"px\");\n}\nwindow.addEventListener(\"click\", function (e) {\n  if (!gamesBtn.contains(e.target) && !dropdown.contains(e.target)) {\n    dropdown.classList.remove(\"show\");\n  }\n});\n\n/**\r\n * Создает DOM-элемент игры локально на основе данных.\r\n * Не отправляет WebSocket сообщение о создании.\r\n * @param {string} id - Уникальный ID элемента игры\r\n * @param {string} gameName - Название игры\r\n * @param {number} x - Координата X\r\n * @param {number} y - Координата Y\r\n * @param {number} width - Ширина\r\n * @param {number} height - Высота\r\n * @returns {HTMLDivElement | null} - Созданный элемент или null, если ошибка\r\n */\nfunction createGameElementLocally(id, gameName, x, y, width, height) {\n  if (gameElements[id]) {\n    console.warn(\"Game element with id \".concat(id, \" already exists locally.\"));\n    return gameElements[id];\n  }\n  var gameWrapper = document.createElement('div');\n  gameWrapper.className = 'paste-game-wrapper';\n  gameWrapper.style.left = x + 'px';\n  gameWrapper.style.top = y + 'px';\n  gameWrapper.style.width = width + 'px';\n  gameWrapper.style.height = height + 'px';\n  gameWrapper.dataset.gameName = gameName;\n  gameWrapper.dataset.id = id; // Сохраняем ID\n\n  var closeBtn = document.createElement('button');\n  closeBtn.className = 'paste-game-close';\n  closeBtn.textContent = '×';\n  closeBtn.onclick = function () {\n    if (isWebSocketActive && ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({\n        type: 'delete_game_element',\n        id: gameWrapper.dataset.id\n      }));\n    } else if (!isWebSocketActive) {\n      // Локальный режим: удаляем сразу\n      if (gameWrapper.classList.contains('active-game')) {\n        clearDynamicSettings();\n      }\n      gameWrapper.remove();\n      delete gameElements[gameWrapper.dataset.id];\n    }\n  };\n  gameWrapper.appendChild(closeBtn);\n  document.querySelector('.canvas-wrapper').appendChild(gameWrapper);\n  makeDraggable(gameWrapper, id);\n  makeResizable(gameWrapper, id);\n\n  // Флаги для отслеживания состояния перетаскивания/изменения размера для этого конкретного элемента\n  gameWrapper.isDragging = false;\n  gameWrapper.isResizing = false;\n  gameWrapper.addEventListener('mousedown', function (e) {\n    // Игнорируем клики на кнопку закрытия и маркер изменения размера, они обрабатываются отдельно\n    if (e.target.closest('.paste-game-close') || e.target.classList.contains('resize-handle')) {\n      return;\n    }\n\n    // Если кликнули на игровой элемент, он должен стать активным\n    if (!gameWrapper.classList.contains('active-game')) {\n      if (isWebSocketActive && ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({\n          type: 'game_element_focus',\n          id: gameWrapper.dataset.id\n        }));\n      } else if (!isWebSocketActive) {\n        // Локальный режим: фокусируем сразу\n        document.querySelectorAll('.paste-game-wrapper.active-game').forEach(function (activeWrapper) {\n          if (activeWrapper !== gameWrapper) {\n            activeWrapper.classList.remove('active-game');\n            activeWrapper.dataset.settingsUpdated = 'false';\n            activeWrapper.style.borderColor = '';\n            activeWrapper.style.zIndex = '';\n          }\n        });\n        gameWrapper.classList.add('active-game');\n        gameWrapper.style.borderColor = 'blue';\n        gameWrapper.style.zIndex = '100';\n        updateGameSettings(gameWrapper.dataset.gameName);\n        gameWrapper.dataset.settingsUpdated = 'true';\n        if (gameWrapper.dataset.gameName === \"puzzles\") {\n          (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.setupWhiteboardPuzzleSaveLoad)();\n        }\n      }\n    } else {\n      gameWrapper.style.zIndex = (parseInt(window.getComputedStyle(gameWrapper).zIndex) || 0) + 1;\n    }\n    clearSelection(); // Снять выделение с картинки на canvas\n    e.stopPropagation();\n  });\n  gameElements[id] = gameWrapper;\n  return gameWrapper;\n}\n\n// Обработка добавления игры на доску\ndocument.querySelectorAll(\".game-option\").forEach(function (option) {\n  if (option.dataset.listenerAttached === 'true') {\n    return;\n  }\n  option.addEventListener(\"click\", function () {\n    var gameName = option.dataset.name;\n    var gameId = \"game-\".concat(nextGameElementId++);\n    var initialX = 100;\n    var initialY = 100;\n    var initialWidth = 400;\n    var initialHeight = 300;\n\n    // Сообщение для отправки или локальной обработки\n    var gameData = {\n      type: 'add_game_element',\n      id: gameId,\n      gameName: gameName,\n      x: initialX,\n      y: initialY,\n      width: initialWidth,\n      height: initialHeight\n    };\n    if (isWebSocketActive && ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(gameData));\n    } else if (!isWebSocketActive) {\n      // Локальный режим для доски\n      var localGameWrapper = createGameElementLocally(gameId, gameName, initialX, initialY, initialWidth, initialHeight);\n      if (localGameWrapper && gameName === \"puzzles\") {\n        if (!localGameWrapper.dataset.puzzleInitialized) {\n          // В локальном режиме roomName будет null, gameId будет сгенерирован.\n          (0,_puzzle_index_js__WEBPACK_IMPORTED_MODULE_0__.createPuzzleOnBoard)(localGameWrapper, null, gameId);\n          localGameWrapper.dataset.puzzleInitialized = \"true\";\n        }\n      }\n      if (ws.send && typeof ws.send === 'function') {\n        ws.send(JSON.stringify({\n          type: 'game_element_focus',\n          id: gameId\n        }));\n      }\n    }\n    dropdown.classList.remove(\"show\");\n  });\n  option.dataset.listenerAttached = 'true';\n});\n\n/**\r\n * Делает контейнер игры перетаскиваемым.\r\n * @param {HTMLDivElement} gameWrapper - Контейнер игры\r\n * @param {string} gameId - Уникальный ID этого игрового элемента\r\n */\nfunction makeDraggable(gameWrapper, gameId) {\n  var dragStartX, dragStartY, initialLeft, initialTop; // Локальные переменные для перетаскивания\n\n  var onElementMouseDown = function onElementMouseDown(e) {\n    // Игнорируем клики на кнопку закрытия и маркер изменения размера\n    if (e.target.closest('.paste-game-close') || e.target.classList.contains('resize-handle')) {\n      return;\n    }\n    // Игнорируем, если клик не левой кнопкой мыши\n    if (e.button !== 0) {\n      return;\n    }\n    // Блокировка перетаскивания только что добавленной игры\n    if (gameWrapper._blockImmediateDrag === true) {\n      return;\n    }\n    gameWrapper.isDragging = true;\n    dragStartX = e.clientX;\n    dragStartY = e.clientY;\n    initialLeft = parseFloat(gameWrapper.style.left) || 0;\n    initialTop = parseFloat(gameWrapper.style.top) || 0;\n    gameWrapper.style.cursor = 'grabbing';\n    document.body.style.userSelect = 'none'; // Предотвращаем выделение текста при перетаскивании\n\n    document.addEventListener('mousemove', onDocumentMouseMoveDrag);\n    document.addEventListener('mouseup', _onDocumentMouseUpDrag);\n    e.stopPropagation();\n  };\n  var onDocumentMouseMoveDrag = function onDocumentMouseMoveDrag(e) {\n    if (!gameWrapper.isDragging) return;\n    var dx = e.clientX - dragStartX;\n    var dy = e.clientY - dragStartY;\n    var newLeft = initialLeft + dx;\n    var newTop = initialTop + dy;\n    gameWrapper.style.left = \"\".concat(newLeft, \"px\");\n    gameWrapper.style.top = \"\".concat(newTop, \"px\");\n\n    // Плавная синхронизация\n    if (!gameElementUpdateScheduled && ws.readyState === WebSocket.OPEN) {\n      gameElementUpdateScheduled = true;\n      requestAnimationFrame(function () {\n        if (gameWrapper.isDragging) {\n          // Проверяем, что все еще тащим\n          ws.send(JSON.stringify({\n            type: 'game_element_drag_update',\n            id: gameId,\n            x: parseFloat(gameWrapper.style.left),\n            y: parseFloat(gameWrapper.style.top)\n          }));\n        }\n        gameElementUpdateScheduled = false;\n      });\n    }\n  };\n  var _onDocumentMouseUpDrag = function onDocumentMouseUpDrag() {\n    if (!gameWrapper.isDragging) return;\n    gameWrapper.isDragging = false;\n    gameWrapper.style.cursor = 'grab';\n    document.body.style.userSelect = '';\n    document.removeEventListener('mousemove', onDocumentMouseMoveDrag);\n    document.removeEventListener('mouseup', _onDocumentMouseUpDrag);\n\n    // Отправка финального состояния\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({\n        type: 'move_game_element',\n        id: gameId,\n        x: parseFloat(gameWrapper.style.left),\n        y: parseFloat(gameWrapper.style.top)\n      }));\n    }\n    gameElementUpdateScheduled = false;\n  };\n  gameWrapper.addEventListener('mousedown', onElementMouseDown);\n  gameWrapper.style.cursor = 'grab';\n}\n\n/**\r\n * Делает контейнер игры изменяемым по размеру.\r\n * @param {HTMLDivElement} gameWrapper - Контейнер игры\r\n * @param {string} gameId - Уникальный ID этого игрового элемента\r\n */\nfunction makeResizable(gameWrapper, gameId) {\n  var resizeHandle = document.createElement('div');\n  resizeHandle.className = 'resize-handle';\n  gameWrapper.appendChild(resizeHandle);\n  var resizeStartX, resizeStartY, initialWidth, initialHeight, initialElementX, initialElementY;\n  resizeHandle.addEventListener('mousedown', function (e) {\n    e.stopPropagation(); // чтобы drag и resize не конфликтовали\n    gameWrapper.isResizing = true;\n    var rect = gameWrapper.getBoundingClientRect(); // Получаем размеры относительно viewport\n    resizeStartX = e.clientX;\n    resizeStartY = e.clientY;\n    initialWidth = rect.width;\n    initialHeight = rect.height;\n    initialElementX = parseFloat(gameWrapper.style.left) || 0;\n    initialElementY = parseFloat(gameWrapper.style.top) || 0;\n    document.body.style.userSelect = 'none';\n    // Используем слушатели на document для отслеживания мыши за пределами элемента\n    document.addEventListener('mousemove', onDocumentMouseMoveResize);\n    document.addEventListener('mouseup', _onDocumentMouseUpResize);\n  });\n  var onDocumentMouseMoveResize = function onDocumentMouseMoveResize(e) {\n    if (!gameWrapper.isResizing) return;\n    var dx = e.clientX - resizeStartX;\n    var dy = e.clientY - resizeStartY;\n    var newWidth = Math.max(200, initialWidth + dx);\n    var newHeight = Math.max(150, initialHeight + dy);\n    gameWrapper.style.width = \"\".concat(newWidth, \"px\");\n    gameWrapper.style.height = \"\".concat(newHeight, \"px\");\n\n    // Плавная синхронизация\n    if (!gameElementUpdateScheduled && ws.readyState === WebSocket.OPEN) {\n      gameElementUpdateScheduled = true;\n      requestAnimationFrame(function () {\n        if (gameWrapper.isResizing) {\n          ws.send(JSON.stringify({\n            type: 'game_element_resize_update',\n            id: gameId,\n            x: parseFloat(gameWrapper.style.left),\n            y: parseFloat(gameWrapper.style.top),\n            width: parseFloat(gameWrapper.style.width),\n            height: parseFloat(gameWrapper.style.height)\n          }));\n        }\n        gameElementUpdateScheduled = false;\n      });\n    }\n  };\n  var _onDocumentMouseUpResize = function onDocumentMouseUpResize() {\n    if (gameWrapper.isResizing) {\n      gameWrapper.isResizing = false;\n      document.body.style.userSelect = '';\n      document.removeEventListener('mousemove', onDocumentMouseMoveResize);\n      document.removeEventListener('mouseup', _onDocumentMouseUpResize);\n\n      // Отправка финального состояния\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({\n          type: 'resize_game_element',\n          id: gameId,\n          x: parseFloat(gameWrapper.style.left),\n          y: parseFloat(gameWrapper.style.top),\n          width: parseFloat(gameWrapper.style.width),\n          height: parseFloat(gameWrapper.style.height)\n        }));\n      }\n      gameElementUpdateScheduled = false;\n    }\n  };\n}\n\n// Панель настроек\nvar toggleButton = document.getElementById('toggle-settings-btn');\nvar settingsPanel = document.querySelector('.settings-panel');\n\n// Открытие/Скрытие настроек\ntoggleButton.addEventListener('click', function () {\n  settingsPanel.classList.toggle('hidden');\n  toggleButton.textContent = settingsPanel.classList.contains('hidden') ? 'Открыть настройки' : 'Закрыть настройки';\n});\n\n/**\r\n * Удаляет все динамически созданные элементы настроек игр.\r\n */\nfunction clearDynamicSettings() {\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) return;\n  var dynamicElements = settingsPanel.querySelectorAll('.dynamic-setting');\n  dynamicElements.forEach(function (el) {\n    return el.remove();\n  });\n  var puzzleSettingsContainer = settingsPanel.querySelector('.puzzle-settings-container');\n  if (puzzleSettingsContainer) {\n    puzzleSettingsContainer.remove();\n  }\n}\n\n/**\r\n * Обновляет панель настроек в зависимости от выбранной игры.\r\n * @param {string} gameName - Название выбранной игры\r\n */\nfunction updateGameSettings(gameName) {\n  var settingsPanel = document.querySelector('.settings-panel');\n  if (!settingsPanel) {\n    console.error(\"Не найдена панель настроек для обновления настроек игры\");\n    return;\n  }\n  if (typeof images === 'undefined') {\n    console.error(\"'переменная images (путь к статическим изображениям) не определена.\");\n    return;\n  }\n  clearDynamicSettings();\n  if (gameName === \"puzzles\") {\n    // Очищаем существующие настройки для пазлов, если они были добавлены ранее\n    var existingSettings = document.querySelector('.puzzle-settings-container');\n    if (existingSettings) {\n      existingSettings.remove();\n    }\n    var settingsContainer = document.createElement('div');\n    settingsContainer.className = \"dynamic-setting puzzle-settings-container\";\n\n    // Проверяем наличие переменной 'images' перед использованием\n    var imagesPath = typeof images !== 'undefined' ? images : '/static/images/default_path';\n\n    // Содержимое настроек\n    var content = \"\\n            <div class=\\\"modal-content\\\">\\n                <h2>\\u041D\\u0430\\u0441\\u0442\\u0440\\u043E\\u0439\\u043A\\u0438 \\u043F\\u0430\\u0437\\u043B\\u0430</h2>\\n                <label for=\\\"puzzle-name\\\">\\u041D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u043B\\u044F \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u0435\\u043D\\u0438\\u044F:</label>\\n                <input type=\\\"text\\\" id=\\\"puzzle-name\\\" placeholder=\\\"\\u041D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0430\\u0437\\u043B\\u0430\\\" style=\\\"width: 80%; padding: 8px; margin-bottom: 15px;\\\">\\n\\n                <h2>\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u043B\\u0430</h2>\\n\\n                <div class=\\\"preset-images\\\">\\n                    <img src=\\\"\".concat(imagesPath, \"/british-cat.jpg\\\" class=\\\"preset\\\" data-src=\\\"\").concat(imagesPath, \"/british-cat.jpg\\\" alt=\\\"\\u0411\\u0440\\u0438\\u0442\\u0430\\u043D\\u0441\\u043A\\u0438\\u0439 \\u043A\\u043E\\u0442\\\">\\n                    <img src=\\\"\").concat(imagesPath, \"/tree.png\\\" class=\\\"preset\\\" data-src=\\\"\").concat(imagesPath, \"/tree.png\\\" alt=\\\"\\u0414\\u0435\\u0440\\u0435\\u0432\\u043E\\\">\\n                </div>\\n\\n                <label class=\\\"upload-label\\\">\\n                    \\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u044C \\u0441\\u0432\\u043E\\u0451:\\n                    <input type=\\\"file\\\" id=\\\"custom-image\\\" accept=\\\"image/*\\\">\\n                </label>\\n\\n                <div id=\\\"image-preview-container\\\" class=\\\"image-preview-container\\\" style=\\\"display: none; margin-top: 10px; text-align: center;\\\">\\n                    <img id=\\\"image-preview\\\" src=\\\"#\\\" alt=\\\"\\u041F\\u0440\\u0435\\u0434\\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\\" style=\\\"max-width: 100px; max-height: 100px; border: 1px solid #ccc; margin-bottom: 5px;\\\">\\n                    <p id=\\\"image-preview-text\\\" style=\\\"font-size: 0.9em; color: #555;\\\">\\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043D\\u043E\\u0435 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435.</p>\\n                </div>\\n\\n                <label for=\\\"difficulty\\\">\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u0441\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C:</label>\\n                <select id=\\\"difficulty\\\">\\n                    <option value=\\\"2\\\" selected>2x2</option>\\n                    <option value=\\\"3\\\">3x3</option>\\n                    <option value=\\\"4\\\">4x4</option>\\n                </select>\\n\\n                <div class=\\\"settings-buttons\\\">\\n                    <button id=\\\"start-game\\\">\\u041D\\u0430\\u0447\\u0430\\u0442\\u044C \\u0438\\u0433\\u0440\\u0443</button> <!-- \\u042D\\u0442\\u0430 \\u043A\\u043D\\u043E\\u043F\\u043A\\u0430 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0441\\u043A\\u0440\\u044B\\u0442\\u0430 JS -->\\n                    <button id=\\\"save-puzzle-btn\\\">\\u0421\\u043E\\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C</button>\\n                    <button id=\\\"load-puzzle-btn\\\">\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u044C</button>\\n                </div>\\n            </div>\\n        \");\n\n    // Вставляем содержимое в контейнер\n    settingsContainer.innerHTML = content;\n\n    // Добавляем в панель настроек\n    settingsPanel.appendChild(settingsContainer);\n  } else if (gameName === \"another-game\") {}\n}\n\n//# sourceURL=webpack://frontend/./whiteboard.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./whiteboard.js");
/******/ 	
/******/ })()
;