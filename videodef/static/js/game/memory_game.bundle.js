/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./memory_game/index.js":
/*!******************************!*\
  !*** ./memory_game/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-game-logic.js */ \"./memory_game/memory-game-logic.js\");\n\n\n/**\r\n * Инициализирует интерфейс и логику для отдельной страницы игры \"Поиск пар\".\r\n * Находит все необходимые DOM-элементы и назначает им обработчики событий.\r\n */\nfunction createMemoryGameSeparately() {\n  // Получаем ссылки на основные DOM-элементы\n  var gameWrapper = document.getElementById('memory-game-wrapper');\n  var pairCountSelect = document.getElementById('pair-count-select');\n  var startButton = document.getElementById('start-memory-game');\n\n  // Элементы панели настроек\n  var gameNameInput = document.getElementById('game-name');\n  var presetSetElements = document.querySelectorAll('.preset-set');\n  var customImagesInput = document.getElementById('custom-images-input');\n  var customImagesPreviewContainer = document.getElementById('custom-images-preview');\n  var previewGrid = customImagesPreviewContainer.querySelector('.preview-grid');\n  var customImagesInfoText = document.getElementById('custom-images-info-text');\n  if (!gameWrapper || !pairCountSelect || !startButton || !gameNameInput || !presetSetElements.length || !customImagesInput || !customImagesPreviewContainer || !previewGrid || !customImagesInfoText) {\n    console.error(\"Критическая ошибка: Не найдены все необходимые DOM-элементы для инициализации игры. Проверьте HTML-разметку и ID элементов.\");\n    return;\n  }\n  var localGameParams = (0,_memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__.getGameParts)();\n\n  // --- Обработчики событий для элементов UI настроек ---\n  gameNameInput.addEventListener('input', function (e) {\n    localGameParams.name = e.target.value.trim();\n  });\n  gameNameInput.value = localGameParams.name;\n  presetSetElements.forEach(function (presetEl) {\n    presetEl.addEventListener('click', function () {\n      presetSetElements.forEach(function (el) {\n        return el.classList.remove('selected');\n      });\n      presetEl.classList.add('selected');\n      var setName = presetEl.dataset.setName;\n      localGameParams.selectedImageSet = (0,_memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__.getFullPresetImageUrls)(setName);\n      localGameParams.isCustomSet = false;\n      customImagesInput.value = '';\n      previewGrid.innerHTML = '';\n      customImagesInfoText.innerHTML = 'Загружено изображений: <span id=\"custom-images-count\">0</span>';\n      customImagesPreviewContainer.style.display = 'none';\n    });\n  });\n  if (presetSetElements.length > 0) {\n    presetSetElements[0].click();\n  }\n  customImagesInput.addEventListener('change', function (event) {\n    var files = event.target.files;\n    previewGrid.innerHTML = '';\n    localGameParams.customImageObjects = [];\n    if (files.length > 0) {\n      localGameParams.isCustomSet = true;\n      presetSetElements.forEach(function (el) {\n        return el.classList.remove('selected');\n      });\n      var loadedCount = 0;\n      Array.from(files).forEach(function (file) {\n        if (!file.type.startsWith('image/')) {\n          console.warn(\"\\u0424\\u0430\\u0439\\u043B \".concat(file.name, \" \\u043D\\u0435 \\u044F\\u0432\\u043B\\u044F\\u0435\\u0442\\u0441\\u044F \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435\\u043C \\u0438 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u043E\\u043F\\u0443\\u0449\\u0435\\u043D.\"));\n          if (++loadedCount === files.length) updateCustomImagePreview();\n          return;\n        }\n        var reader = new FileReader();\n        reader.onload = function (e) {\n          localGameParams.customImageObjects.push({\n            url: e.target.result,\n            file: file\n          });\n          var imgPreview = document.createElement('img');\n          imgPreview.src = e.target.result;\n          imgPreview.alt = file.name;\n          imgPreview.classList.add('preview-thumb');\n          previewGrid.appendChild(imgPreview);\n          if (++loadedCount === files.length) updateCustomImagePreview();\n        };\n        reader.onerror = function () {\n          console.error(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u0447\\u0442\\u0435\\u043D\\u0438\\u044F \\u0444\\u0430\\u0439\\u043B\\u0430 \".concat(file.name));\n          if (++loadedCount === files.length) updateCustomImagePreview();\n        };\n        reader.readAsDataURL(file);\n      });\n    } else {\n      localGameParams.isCustomSet = false;\n      var currentlySelectedPreset = document.querySelector('.preset-set.selected') || presetSetElements[0];\n      if (currentlySelectedPreset) {\n        currentlySelectedPreset.click();\n      } else {\n        updateCustomImagePreview();\n      }\n    }\n  });\n\n  /**\r\n   * Обновляет отображение предпросмотра пользовательских изображений.\r\n   */\n  function updateCustomImagePreview() {\n    if (localGameParams.isCustomSet && localGameParams.customImageObjects.length > 0) {\n      customImagesInfoText.innerHTML = \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0439: <span id=\\\"custom-images-count\\\">\".concat(localGameParams.customImageObjects.length, \"</span>\");\n      customImagesPreviewContainer.style.display = 'block';\n    } else {\n      customImagesInfoText.innerHTML = 'Загружено изображений: <span id=\"custom-images-count\">0</span>';\n      customImagesPreviewContainer.style.display = 'none';\n    }\n  }\n\n  // --- Логика старта и управления игрой ---\n  /**\r\n   * Запускает или перезапускает игру с текущими настройками.\r\n   */\n  var startGame = function startGame() {\n    localGameParams.pairCount = parseInt(pairCountSelect.value, 10);\n    (0,_memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__.stopTimer)(localGameParams);\n    var success = (0,_memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__.initializeBoard)(gameWrapper, localGameParams);\n  };\n  pairCountSelect.addEventListener('change', function () {\n    localGameParams.pairCount = parseInt(pairCountSelect.value, 10);\n    gameWrapper.innerHTML = '<p class=\"initial-message\">Настройки изменены. Нажмите \"Начать игру\", чтобы применить.</p>';\n    if (localGameParams.uiCompletionMessageEl) {\n      localGameParams.uiCompletionMessageEl.style.display = 'none';\n    }\n    (0,_memory_game_logic_js__WEBPACK_IMPORTED_MODULE_0__.stopTimer)(localGameParams);\n  });\n  startButton.addEventListener('click', startGame);\n  console.log(\"Страница игры 'Поиск пар' инициализирована.\");\n}\nwindow.MemoryGameModule = window.MemoryGameModule || {};\nwindow.MemoryGameModule.createMemoryGameSeparately = createMemoryGameSeparately;\n\n//# sourceURL=webpack://frontend/./memory_game/index.js?");

/***/ }),

/***/ "./memory_game/memory-game-logic.js":
/*!******************************************!*\
  !*** ./memory_game/memory-game-logic.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFullPresetImageUrls: () => (/* binding */ getFullPresetImageUrls),\n/* harmony export */   getGameParts: () => (/* binding */ getGameParts),\n/* harmony export */   initializeBoard: () => (/* binding */ initializeBoard),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   stopTimer: () => (/* binding */ stopTimer)\n/* harmony export */ });\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar PRESET_IMAGE_SETS_CONFIG = {\n  fruits: ['fruits/apple.png', 'fruits/banana.png', 'fruits/cherry.png', 'fruits/grapes.png', 'fruits/lemon.png', 'fruits/orange.png', 'fruits/strawberry.png', 'fruits/pineapple.png', 'fruits/kiwi.png', 'fruits/watermelon.png', 'fruits/mango.png', 'fruits/coconut.png'],\n  animals: ['animals/panda.png', 'animals/fox.png', 'animals/bear.png', 'animals/koala.png', 'animals/tiger.png', 'animals/lion.png', 'animals/cow.png', 'animals/pig.png', 'animals/frog.png', 'animals/monkey.png', 'animals/chicken.png', 'animals/penguin.png']\n};\n\n/**\r\n * Генерирует полные URL-адреса для изображений из предустановленного набора.\r\n * Использует глобальную переменную `presetImagesBasePath`, определенную в HTML.\r\n * @param {string} setName - Имя набора из PRESET_IMAGE_SETS_CONFIG.\r\n * @returns {string[]} Массив полных URL-адресов изображений или пустой массив в случае ошибки.\r\n */\nfunction getFullPresetImageUrls(setName) {\n  if (PRESET_IMAGE_SETS_CONFIG[setName] && typeof presetImagesBasePath !== 'undefined') {\n    return PRESET_IMAGE_SETS_CONFIG[setName].map(function (relativePath) {\n      return presetImagesBasePath + relativePath;\n    });\n  }\n  console.warn(\"\\u041D\\u0430\\u0431\\u043E\\u0440 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0439 \\\"\".concat(setName, \"\\\" \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D \\u0438\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F presetImagesBasePath \\u043D\\u0435 \\u043E\\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0435\\u043D\\u0430.\"));\n  return [];\n}\n\n// Имя предустановленного набора по умолчанию\nvar DEFAULT_PRESET_NAME = 'fruits';\n\n/**\r\n * Рассчитывает оптимальное количество строк и столбцов для сетки карточек.\r\n * Стремится сделать поле как можно более квадратным.\r\n * @param {number} totalCards - Общее количество карточек.\r\n * @returns {{rows: number, cols: number}} Объект с количеством строк и столбцов.\r\n */\nfunction calculateGridDimensions(totalCards) {\n  var bestRows = 1;\n  var bestCols = totalCards;\n  var minDiff = totalCards - 1;\n\n  // Ищем делители числа totalCards, чтобы найти возможные конфигурации сетки\n  for (var rows = 1; rows * rows <= totalCards; rows++) {\n    if (totalCards % rows === 0) {\n      var cols = totalCards / rows;\n      // Если текущая разница меньше предыдущей минимальной, обновляем лучшие значения\n      if (Math.abs(rows - cols) < minDiff) {\n        minDiff = Math.abs(rows - cols);\n        bestRows = rows;\n        bestCols = cols;\n      } else if (Math.abs(rows - cols) === minDiff) {\n        // Если разница та же, предпочитаем вариант, где строк меньше или равно столбцам\n        if (rows < bestRows) {\n          bestRows = rows;\n          bestCols = cols;\n        }\n      }\n    }\n  }\n  return bestRows > bestCols ? {\n    rows: bestCols,\n    cols: bestRows\n  } : {\n    rows: bestRows,\n    cols: bestCols\n  };\n}\n\n/**\r\n * Создает и возвращает объект с начальными параметрами игры.\r\n * @returns {object} Объект с параметрами игры.\r\n */\nfunction getGameParts() {\n  return {\n    // Параметры по умолчанию\n    name: \"Моя игра в пары\",\n    pairCount: 4,\n    selectedImageSet: getFullPresetImageUrls(DEFAULT_PRESET_NAME),\n    isCustomSet: false,\n    customImageObjects: [],\n    gridSize: {\n      rows: 0,\n      cols: 0\n    },\n    cardContentSet: [],\n    firstSelectedCard: null,\n    secondSelectedCard: null,\n    matchesFound: 0,\n    totalMatches: 0,\n    attempts: 0,\n    lockBoard: false,\n    timerInterval: null,\n    secondsElapsed: 0,\n    // Ссылки на DOM-элементы для обновления UI (инициализируются в initializeBoard)\n    uiTimeEl: null,\n    uiAttemptsEl: null,\n    uiCompletionMessageEl: null,\n    uiCompletionTextEl: null\n  };\n}\n\n/**\r\n * Перемешивает элементы массива случайным образом (алгоритм Фишера-Йетса).\r\n * @param {Array<any>} array - Массив для перемешивания.\r\n * @returns {Array<any>} Новый массив с перемешанными элементами.\r\n */\nfunction shuffle(array) {\n  var newArray = _toConsumableArray(array);\n  for (var i = newArray.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var _ref = [newArray[j], newArray[i]];\n    newArray[i] = _ref[0];\n    newArray[j] = _ref[1];\n  }\n  return newArray;\n}\n\n/**\r\n * Инициализирует и создает игровое поле.\r\n * @param {HTMLElement} boardWrapper - DOM-элемент, в который будет встроено игровое поле (`.memory-game-wrapper`).\r\n * @param {object} gameParams - Объект с текущими параметрами игры.\r\n * @returns {boolean} `true` если инициализация прошла успешно, `false` в случае ошибки (например, нехватка изображений).\r\n */\nfunction initializeBoard(boardWrapper, gameParams) {\n  // Сбрасываем ссылки на DOM-элементы\n  gameParams.uiTimeEl = null;\n  gameParams.uiAttemptsEl = null;\n  gameParams.uiCompletionMessageEl = null;\n  gameParams.uiCompletionTextEl = null;\n\n  // Очищаем обертку от предыдущего содержимого\n  boardWrapper.innerHTML = '';\n\n  // Создаем главный контейнер для игровой доски=\n  var gameBoard = document.createElement('div');\n  gameBoard.className = 'memory-game-board';\n  boardWrapper.appendChild(gameBoard);\n\n  // Создаем панель с информацией о ходе игры\n  var gameDetailsBar = document.createElement('div');\n  gameDetailsBar.className = 'game-details-bar';\n  gameDetailsBar.innerHTML = \"\\n        <p class=\\\"time\\\">\\u0412\\u0440\\u0435\\u043C\\u044F: <b data-role=\\\"time\\\">0</b>\\u0441</p>\\n        <p class=\\\"moves\\\">\\u0425\\u043E\\u0434\\u044B: <b data-role=\\\"attempts\\\">0</b></p>\\n    \";\n  gameBoard.appendChild(gameDetailsBar);\n  gameParams.uiTimeEl = gameDetailsBar.querySelector('b[data-role=\"time\"]');\n  gameParams.uiAttemptsEl = gameDetailsBar.querySelector('b[data-role=\"attempts\"]');\n\n  // Создаем контейнер для сетки карточек\n  var cardsGridContainer = document.createElement('div');\n  cardsGridContainer.className = 'cards-grid-container';\n  gameBoard.appendChild(cardsGridContainer);\n\n  // Создаем DOM-элемент для сообщения о завершении игры, если он еще не был создан.\n  if (!gameParams.uiCompletionMessageEl) {\n    var completionMessageDiv = document.createElement('div');\n    completionMessageDiv.id = 'game-completion-message';\n    completionMessageDiv.style.display = 'none';\n    var completionTextP = document.createElement('p');\n    completionMessageDiv.appendChild(completionTextP);\n    boardWrapper.appendChild(completionMessageDiv);\n    gameParams.uiCompletionMessageEl = completionMessageDiv;\n    gameParams.uiCompletionTextEl = completionTextP;\n  } else {\n    gameParams.uiCompletionMessageEl.style.display = 'none';\n  }\n\n  // Обновляем/сбрасываем игровые параметры\n  gameParams.totalMatches = gameParams.pairCount;\n  var totalCards = gameParams.pairCount * 2;\n  gameParams.gridSize = calculateGridDimensions(totalCards);\n  gameParams.matchesFound = 0;\n  gameParams.attempts = 0;\n  gameParams.firstSelectedCard = null;\n  gameParams.secondSelectedCard = null;\n  gameParams.lockBoard = false;\n  gameParams.secondsElapsed = 0;\n\n  // Подготовка набора изображений для игры\n  var imagesForGame;\n  if (gameParams.isCustomSet) {\n    // Если используется пользовательский набор\n    // Проверяем, достаточно ли загружено уникальных изображений для выбранного количества пар\n    if (gameParams.customImageObjects.length < gameParams.pairCount) {\n      boardWrapper.innerHTML = \"<p class=\\\"initial-message\\\">\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D\\u043E \".concat(gameParams.customImageObjects.length, \" \\u0443\\u043D\\u0438\\u043A\\u0430\\u043B\\u044C\\u043D\\u044B\\u0445 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0439, \\u0430 \\u043D\\u0443\\u0436\\u043D\\u043E \").concat(gameParams.pairCount, \" \\u0434\\u043B\\u044F \\u043F\\u0430\\u0440. \\u041F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430, \\u0437\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u0435 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0439 \\u0438\\u043B\\u0438 \\u0432\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0443\\u044E \\u0441\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C.</p>\");\n      if (gameParams.uiCompletionMessageEl) gameParams.uiCompletionMessageEl.style.display = 'none';\n      updateUIDetails(gameParams);\n      return false;\n    }\n    var uniqueCustomUrls = gameParams.customImageObjects.slice(0, gameParams.pairCount).map(function (obj) {\n      return obj.url;\n    });\n    imagesForGame = shuffle([].concat(_toConsumableArray(uniqueCustomUrls), _toConsumableArray(uniqueCustomUrls)));\n  } else {\n    // Если используется предустановленный набор\n    // Проверяем, достаточно ли изображений в выбранном пресете\n    if (gameParams.selectedImageSet.length < gameParams.pairCount) {\n      boardWrapper.innerHTML = \"<p class=\\\"initial-message\\\">\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0412 \\u0432\\u044B\\u0431\\u0440\\u0430\\u043D\\u043D\\u043E\\u043C \\u043D\\u0430\\u0431\\u043E\\u0440\\u0435 \".concat(gameParams.selectedImageSet.length, \" \\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0439, \\u0430 \\u043D\\u0443\\u0436\\u043D\\u043E \").concat(gameParams.pairCount, \" \\u0434\\u043B\\u044F \\u043F\\u0430\\u0440. \\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439 \\u043D\\u0430\\u0431\\u043E\\u0440 \\u0438\\u043B\\u0438 \\u0441\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C.</p>\");\n      if (gameParams.uiCompletionMessageEl) gameParams.uiCompletionMessageEl.style.display = 'none';\n      updateUIDetails(gameParams);\n      return false;\n    }\n    var neededImageUrls = gameParams.selectedImageSet.slice(0, gameParams.pairCount);\n    imagesForGame = shuffle([].concat(_toConsumableArray(neededImageUrls), _toConsumableArray(neededImageUrls)));\n  }\n  gameParams.cardContentSet = imagesForGame; // Сохраняем подготовленный набор URL-ов\n\n  // Настраиваем CSS Grid для контейнера карточек\n  cardsGridContainer.style.gridTemplateColumns = \"repeat(\".concat(gameParams.gridSize.cols, \", 1fr)\");\n  cardsGridContainer.style.gridTemplateRows = \"repeat(\".concat(gameParams.gridSize.rows, \", 1fr)\");\n\n  // Создаем и добавляем карточки на поле\n  gameParams.cardContentSet.forEach(function (imageUrl, index) {\n    var cardItem = document.createElement('div');\n    cardItem.classList.add('memory-card');\n    cardItem.dataset.imageUrl = imageUrl;\n    cardItem.dataset.id = index;\n\n    // Создаем лицевую сторону карточки\n    var frontFace = document.createElement('div');\n    frontFace.classList.add('card-face', 'front');\n    var img = document.createElement('img');\n    img.src = imageUrl;\n    img.alt = \"Изображение карточки\";\n    img.classList.add('card-face-image');\n    frontFace.appendChild(img);\n\n    // Создаем оборотную сторону (рубашку)\n    var backFace = document.createElement('div');\n    backFace.classList.add('card-face', 'back');\n\n    // Добавляем лицевую и оборотную стороны в контейнер карточки\n    cardItem.appendChild(frontFace);\n    cardItem.appendChild(backFace);\n\n    // Назначаем обработчик клика\n    cardItem.addEventListener('click', function () {\n      return handleCardClick(cardItem, gameParams);\n    });\n    cardsGridContainer.appendChild(cardItem);\n  });\n  updateUIDetails(gameParams);\n  startTimer(gameParams);\n  return true;\n}\n\n/**\r\n * Обновляет отображение времени и количества ходов в UI.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction updateUIDetails(gameParams) {\n  if (gameParams.uiTimeEl) gameParams.uiTimeEl.textContent = gameParams.secondsElapsed;\n  if (gameParams.uiAttemptsEl) gameParams.uiAttemptsEl.textContent = gameParams.attempts;\n}\n\n/**\r\n * Обрабатывает клик по карточке.\r\n * @param {HTMLElement} clickedCard - DOM-элемент карточки, по которой кликнули.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction handleCardClick(clickedCard, gameParams) {\n  if (gameParams.lockBoard || clickedCard === gameParams.firstSelectedCard || clickedCard.classList.contains('flipped') || clickedCard.classList.contains('matched') || gameParams.matchesFound === gameParams.totalMatches) {\n    return;\n  }\n  clickedCard.classList.add('flipped');\n  if (!gameParams.firstSelectedCard) {\n    // Если это первая выбранная карточка\n    gameParams.firstSelectedCard = clickedCard;\n    return;\n  }\n  // Если это вторая выбранная карточка\n  gameParams.secondSelectedCard = clickedCard;\n  gameParams.lockBoard = true;\n  gameParams.attempts++;\n  updateUIDetails(gameParams);\n  checkForMatch(gameParams);\n}\n\n/**\r\n * Проверяет, совпадают ли две выбранные карточки.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction checkForMatch(gameParams) {\n  var isMatch = gameParams.firstSelectedCard.dataset.imageUrl === gameParams.secondSelectedCard.dataset.imageUrl;\n  if (isMatch) {\n    gameParams.matchesFound++;\n    gameParams.firstSelectedCard.classList.add('matched');\n    gameParams.secondSelectedCard.classList.add('matched');\n    resetTurn(gameParams);\n    checkVictory(gameParams);\n  } else {\n    // Устанавливаем таймаут, чтобы игрок успел увидеть вторую карточку перед тем, как они перевернутся обратно\n    setTimeout(function () {\n      if (gameParams.firstSelectedCard) gameParams.firstSelectedCard.classList.remove('flipped');\n      if (gameParams.secondSelectedCard) gameParams.secondSelectedCard.classList.remove('flipped');\n      resetTurn(gameParams);\n    }, 1000);\n  }\n}\n\n/**\r\n * Сбрасывает состояние выбора карт (firstSelectedCard, secondSelectedCard) и разблокирует доску.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction resetTurn(gameParams) {\n  gameParams.firstSelectedCard = null;\n  gameParams.secondSelectedCard = null;\n  gameParams.lockBoard = false;\n}\n\n/**\r\n * Проверяет, найдены ли все пары, и отображает сообщение о победе.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction checkVictory(gameParams) {\n  if (gameParams.matchesFound === gameParams.totalMatches && gameParams.totalMatches > 0) {\n    stopTimer(gameParams);\n    if (gameParams.uiCompletionMessageEl && gameParams.uiCompletionTextEl) {\n      gameParams.uiCompletionTextEl.textContent = \"\\u041F\\u043E\\u0437\\u0434\\u0440\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C! \\u0412\\u044B \\u043D\\u0430\\u0448\\u043B\\u0438 \\u0432\\u0441\\u0435 \".concat(gameParams.totalMatches, \" \\u043F\\u0430\\u0440\\u044B \\u0437\\u0430 \").concat(gameParams.attempts, \" \\u0445\\u043E\\u0434\\u043E\\u0432 \\u0438 \").concat(gameParams.secondsElapsed, \"\\u0441!\");\n      gameParams.uiCompletionMessageEl.style.display = 'block';\n    } else {\n      console.error(\"Элементы сообщения о победе не найдены в gameParams при проверке победы.\");\n    }\n  }\n}\n\n/**\r\n * Запускает игровой таймер.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction startTimer(gameParams) {\n  stopTimer(gameParams);\n  gameParams.secondsElapsed = 0;\n  updateUIDetails(gameParams);\n  gameParams.timerInterval = setInterval(function () {\n    gameParams.secondsElapsed++;\n    updateUIDetails(gameParams);\n  }, 1000);\n}\n\n/**\r\n * Останавливает игровой таймер.\r\n * @param {object} gameParams - Объект с параметрами игры.\r\n */\nfunction stopTimer(gameParams) {\n  if (gameParams.timerInterval) {\n    clearInterval(gameParams.timerInterval);\n    gameParams.timerInterval = null;\n  }\n}\n\n//# sourceURL=webpack://frontend/./memory_game/memory-game-logic.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./memory_game/index.js");
/******/ 	
/******/ })()
;